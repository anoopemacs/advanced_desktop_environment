* qutebrowser configuration                                  :qute:qutebrowser:
:PROPERTIES:
:VISIBILITY: FOLDED
:END:
** installation
+pacman -S qutebrowser+ #its really small, only ~20MB

I installed it into a virtualenv
#+begin_quote https://qutebrowser.org/doc/install.html
Running scripts/mkvenv.py does not install a system-wide qutebrowser script.
#+end_quote

I manually created two files to launch it
#+begin_src bash :tangle "/usr/local/bin/qutebrowser" :tangle-mode o755
#!/bin/bash
~/Documents/qutebrowser/.venv/bin/python3 -m qutebrowser "$@"
#+end_src

This launcher will reuse an existing process, if any, to speed up the launching of tabs
#+begin_src bash :tangle "~/.local/bin/qutebrowser" :tangle-mode o755
#!/bin/sh
# initial idea: Florian Bruhin (The-Compiler)
# author: Thore B√∂decker (foxxx0)
# Ans num 17 on https://qutebrowser.org/doc/faq.html

_url="$1"
_qb_version='3.3.1'
_proto_version=1
_ipc_socket="${XDG_RUNTIME_DIR}/qutebrowser/ipc-$(echo -n "$USER" | md5sum | cut -d' ' -f1)"
_qute_bin="/usr/local/bin/qutebrowser"

printf '{"args": ["%s"], "target_arg": null, "version": "%s", "protocol_version": %d, "cwd": "%s"}\n' \
       "${_url}" \
       "${_qb_version}" \
       "${_proto_version}" \
       "${PWD}" | socat -lf /dev/null - UNIX-CONNECT:"${_ipc_socket}" || "$_qute_bin" "$@" &
#+end_src

Launch qutebrowser and run =:adblock-update=

Notice that there is a bit of confusing indirection involved in the qutebrowser launch script. =~/.local/bin/qutebrowser= will launch =/usr/local/bin/qutebrowser= will eventually launch =qutbrowser.py= inside its virtual environment.

** Add a verbose config file template
Now start reading this docs page [[https://qutebrowser.org/doc/help/configuring.html][Configuring qutebrowser | qutebrowser]]

# Of the [[https://qutebrowser.org/doc/help/configuring.html#configpy:~:text=Various%20emacs/conkeror%2Dlike%20keybinding%20configs%20exist%3A][5 official docs recommended]] qutebrowser-emacs-bindings repos;
# At first glance, [[https://gitlab.com/Kaligule/qutebrowser-emacs-config/blob/master/config.py][Kaligule's]] seems the most comprehensive based on num of line & recent based on last modified

# So, let me copycat Kaligule's config as a starting point.
# His config contains a single config.py file

# As per docs, the location of config file is at ~/.config/qutebrowser/config.py
# So, let me copy his config to that location. see [[*=config.py=][=config.py=]]

# Hereon, my customisations will be noweb-ref inserted into that^ org heading

At second glance, I think it might be better to start out with the default config.
I can generate a starting template for config.py containing the default settings by running  =:config-write-py --defaults=

You can easily reload this config after making changes by running =:config-source=

** dont permit GUI settings panel to change config
The single source of config truth should be the config.py file.
Because I dont ever use qutebrowser gui to configure its options.
Instead, I will exclusively use config.py.
#+begin_src python :noweb-ref "No gui config"
config.load_autoconfig(False)
#+end_src

** what is the default ~c~ object
It is a shorthand for config.set() method access

** COMMENT append url to buffer name using greasemonkey userscript
:PROPERTIES:
:VISIBILITY: FOLDED
:END:
disabled because I was able to accomplish this using ~c.window.title_format~

My elisp [[file:~/.emacs.d/new.org::*exwm use-package][config]] in new.org automatically adds window title to buffer name
Therefore, all I need to do is just add url to qutebrowser title

       (by greasemonkey userscript)                  (by elisp in new.org elisp config)
Url ---------------------------------> Window title -------------------------------> Buffer name

The greasemonkey userscript:-
#+begin_src js :tangle ~/.config/qutebrowser/greasemonkey/url_in_title.user.js
// ==UserScript==
// @name        URL to Title
// @namespace   GB
// @include http://*/*
// @include https://*/*
// @version     1
// @grant       GM_log
// @description Append url to qutebrowser window title
// ==/UserScript==

var path = window.location.pathname.split("/")
var currentURL = window.location.href;
var currentTitle = document.title;

var title = String(currentTitle) + "üåê" + String(currentURL);
//console.log("Planning to set title to:", title);

// code from Facebook script - ensures that title remains changed
var target = document.querySelector('title');
var config = { attributes: true, childList: true, characterData: true }
var observer = new MutationObserver(function(mutations) {
  mutations.forEach(function(mutation) {
    observer.disconnect();

    document.title = title;

    observer.observe(target, config);
  });
});
//console.log("The target node is: ", target);
observer.observe(target, config);

unsafeWindow.onload = function(){
  //This is a dirty hack to trigger the mutation observer defined above
  //console.log("anoop's trigger0, force a change of title");
  document.title = "temp window title, hardcoded inside a greasemonkey script";
};
#+end_src

BTW, :yank without any selection, will copy current url to clipboard.
** old reddit redirect, greasemonkey script
#+begin_src js :tangle ~/.config/qutebrowser/greasemonkey/oldRedditRedirect.user.js :comments no
// ==UserScript==
// @name Old Reddit Redirect
// @version      0.1.1
// @description  redirects you to old.reddit.com
// @author       github.com/richkmls
// @match *://*.reddit.com/*
// @exclude /^https?://[a-z]{2}\.reddit\.com/*
// @exclude *out.reddit.com/*
// @exclude *://*.reddit.com/gallery/*
// @exclude *://*.reddit.com/media*
// @run-at document-start
// @grant        none
// ==/UserScript==

// Enforce strict mode for better code quality
'use strict';

// Declare constant for current URL
const currentUrl = window.location.href;

// Declare constant for old reddit URL
const oldRedditUrl = 'https://old.reddit.com/';

// Check if the current URL does not include old.reddit.com
if (!currentUrl.includes("old.reddit.com")) {

  // Use regex literal and constant for new URL
  const newUrl = currentUrl.replace(/^https?:\/\/(www\.)?reddit.com\//, oldRedditUrl);

  // Redirect to new URL without history entry
  window.location.replace(newUrl);
}
#+end_src

** hide reddit sidebar, greasemonkey script
#+begin_src js :tangle ~/.config/qutebrowser/greasemonkey/remove-reddit-sidebar.user.js  :comments no
// ==UserScript==
// @name           Reddit - Hide sidebar 
// @namespace      https://greasyfork.org/users/5174-jesuis-parapluie
//
// @description	   Autohides Reddit sidebar and adds a button to toggle view
//
// @include        http://*.reddit.com/*
// @include        https://*.reddit.com/*
//
// @require        http://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js
//
// @grant none 
//
// @version		   0.0.4
// ==/UserScript==
 
$.noConflict();
jQuery( document ).ready(function( $ ) {
  $(".tabmenu").append($('<li>', {html: '<a href="#">sidebar</a>'}).click(function(){$(".side").toggle()}));
  $(".side").toggle();
});
#+end_src

** COMMENT ShowHN, show the programming language used, greasemonkey script
not working. Maybe because ~GM_xmlhttpRequest~ isnt yet supported properly by qutebrowser
#+begin_src js :tangle ~/.config/qutebrowser/greasemonkey/showhn-detect-programming-language.user.js  :comments no
// ==UserScript==
// @name         Show HN must depict Programming Languages
// @namespace    http://tampermonkey.net/
// @version      0.1
// @description  For SHOW HN subimssions, show the Github programming languages used next to them
// @author       Anoop
// @match        https://news.ycombinator.com/show
// @icon         https://www.google.com/s2/favicons?sz=64&domain=ycombinator.com
// @grant        GM_xmlhttpRequest
// @connect      github.com
// ==/UserScript==


function get_github_language(link) {
  console.log("helper called");

  //some submitted urls may not point to the project homepage, so need to ensure I trim links to end at project homepage
  //it is the homepage of the project that contains the programming language used
  var split_link = link.href.split('/');
  console.log(split_link);
  var relevant_link = split_link.slice(0, 5);
  console.log(split_link.slice(0, 5));
  var project_homepage_link = relevant_link.join("/");
  console.log(project_homepage_link);

  //now lets fetch the project homepage
  GM_xmlhttpRequest ( {
    method:     'GET',
    url:        project_homepage_link,
    onload:     function (responseDetails) {
      //We will extract the relevant Programming Languages bit from the responseText
      //We need to use a trick to parse the xml request response as html:-
      //trick source:- https://en.wikibooks.org/wiki/JavaScript/Handling_HTML
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = responseDetails.responseText;
      var relevant1 = tempDiv.querySelectorAll("li.d-inline a[data-ga-click='Repository, language stats search click, location:repo overview']");
      console.log("This contains the programming language:-", relevant1);

      // convert the node relevant1 into htmltext for insertion into DOM
      var relevant1_html = Array.prototype.reduce.call(relevant1, function(html, node) {
        return html + ( node.outerHTML || node.nodeValue );
      }, "");
      // insert as a sibling to the /link/
      link.insertAdjacentHTML("afterend", relevant1_html);
    }
  });
}

(function() {
  'use strict';
  console.log("Script is getting called000007");
  var links = document.links
  for (var i = 0; i != links.length; ++i) {
    var link = links[i];
    if (link.href.startsWith("https://github.com/")) {
      console.log(link);
      link.style.textDecoration = 'underline';
      get_github_language(link);
      break;
    }
  }
})();
#+end_src
** COMMENT redirect twitter to nitter, greasemonkey script
^nitter is down these days
(Look into alternative nitter frontends at [[https://github.com/zedeus/nitter/wiki/Instances][Instances ¬∑ zedeus/nitter Wiki]])

Below stopped working when nitter.net went down
#+begin_src js :tangle ~/.config/qutebrowser/greasemonkey/nitter.user.js  :comments no
// ==UserScript==
// @name           Twitter to Nitter
// @namespace      Zera's userscripts
// @include        *twitter.com*
// @grant          none
// @run-at         document-start
// ==/UserScript==
url = location.href
url = url.replace(/\bwww\.\b/, "")
//url = url + "?theme=Twitter" //this enables a light color theme, default is a dark theme
if (url.includes("mobile.twitter.com")){
  url = url.replace("mobile.twitter.com","nitter.net")
  location.href = url
}
else{
  url = url.replace("twitter.com","nitter.net")
  location.href = url
}
#+end_src

I require an implementation that automatically picks a nitter server that is not down.
Look into [[https://raw.githubusercontent.com/dybdeskarphet/privacy-redirector/main/privacy-redirector.user.js][this userscript]] & [[https://farside.link][Farside.link randomly picks a working instance of nitter]]

** CANCELLED COMMENT Github user languages, greasemonkey script
^dont waste time building such shits. Just open Google Chrome for such one time usecases.

built [[https://github.com/freyamade/github-user-languages][freyamade/github-user-languages: Browser extension that adds little language pie charts to a user's profile page on GitHub.]]
required me to add ~export NODE_OPTIONS=--openssl-legacy-provider~ when using node latest lts

Let me symlink the built js file to my userscript directory

#+begin_src bash :results output verbatim
ln -s ~/today/2024-01-02/github-user-languages/dist/js/content_script.js ~/.config/qutebrowser/greasemonkey/github-user-languages.user.js
#+end_src

#+RESULTS:

#+begin_src txt Add the header manually:-
// ==UserScript==
// @name           Github User Languages
// @namespace      freyamade
// @include        *github.com*
// @grant          none
// @run-at         document-start
// ==/UserScript==
#+end_src

todo, currently doesnt work


** google translate, userscript
Let me create the directory for storing userscripts
#+begin_src bash :results output verbatim
mkdir ~/.local/share/qutebrowser/userscripts
#+end_src

#+RESULTS:

#+begin_src bash :results output :wrap "src bash :tangle-mode o755 :tangle ~/.local/share/qutebrowser/userscripts/translate"
curl https://raw.githubusercontent.com/AckslD/Qute-Translate/master/translate
#+end_src

#+RESULTS:
#+begin_src bash :tangle-mode o755 :tangle ~/.local/share/qutebrowser/userscripts/translate
#!/bin/bash

while [[ $# > 0 ]]; do
    case $1 in
        -s|--source)
            QUTE_TRANS_SOURCE=$2
            shift
            shift
            ;;
        -t|--target)
            QUTE_TRANS_TARGET=$2
            shift
            shift
            ;;
        --url)
            QUTE_TRANS_URL="true"
            shift
            ;;
        --text)
            QUTE_TRANS_URL="false"
            shift
            ;;
    esac
done

if [[ -z $QUTE_TRANS_SOURCE ]]; then
    # Default use automatic language for source
    QUTE_TRANS_SOURCE="auto"
fi
if [[ -z $QUTE_TRANS_TARGET ]]; then
    # Default use English for target
    QUTE_TRANS_TARGET="en"
fi

if [[ $QUTE_TRANS_URL == "false" ]]; then
    # Translate selected text
    PAGE="https://translate.google.com/#view=home&op=translate&"
    CONT_KEY="text"
    CONTENT=$QUTE_SELECTED_TEXT
else
    # Default translate URL
    PAGE="https://translate.google.com/translate?"
    CONT_KEY="u"
    CONTENT=$QUTE_URL
fi

echo "open -t ${PAGE}sl=$QUTE_TRANS_SOURCE&tl=$QUTE_TRANS_TARGET&$CONT_KEY=$CONTENT" >> "$QUTE_FIFO"
#+end_src

** disable tabs and tab bar
#+begin_src python :noweb-ref "Disable tabs"
c.tabs.tabs_are_windows = True
c.tabs.show = 'never'
#+end_src
** set qutebrowser as default browser
See elisp at [[file:~/.emacs.d/new.org::*Qutebrowser config][Qutebrowser config]]
** Copy selected text as an orgmode quote. tldr: =C-M-w=
Note that this is part implemented in qutebrowser config, part as a helper function in my emacs config.
Whereas, =C-c M-w= is configured entirely in my emacs config.

The next three org subheadings explain Userscript vs Greasemonkey script vs jseval:-
*** COMMENT :spawn node script.js is also a deadend
Let me see if ~:spawn node blabla.js~ works

I see that sleep works, ~:spawn node sleep 5~, htop does show a sleep command being run.
~:spawn emacsclient --eval '(message "Hello from spawn")'~ also works!

*I have run into a dead end. There is no way to pass the ~window~ object through spawn. But, ~window.getSelection()~ is needed to pass selection text.*
#+begin_src conf
:spawn WINDOW=window node ~/.config/qutebrowser/userscripts/copy-url-to-selected-text-fragment.node.js
#+end_src

**** TODO unexplored workarounds
+There is some ray of hope though. To circumvent this, I can make use of ~$QUTE_SELECTED_TEXT~ environment variable.+
That environment variable is passed ONLY to userscripts.

?Another solution could be to set ubuntu to always copy primary selection to clipboard.a
#+begin_quote https://old.reddit.com/r/qutebrowser/comments/k95fzf/handling_selected_text_with_multiple_lines_for/
Well i 'm not sure how to solve your problem from within qutebrowser (\, but) on my archlinux machine (\, whenever) i select text it copies it to the clipboard. So you could just select the text and run a script that takes its input from the clipboard. Thats what i do for translating text. Plus it works everywhere (\, not) just qutebrowser.
#+end_quote

*** COMMENT :jseval is also a deadend
*It seems that I need access to the ~window~ object*
Greasemonkey scripts do have access to it.
But I couldnt figure out how to bind greasemonkey script to a qutebrowser command.

Therefore, I will be using the ~:jseval~ command in qutebrowser.
This has access to the ~window~ object and can be bound to a qutebrowser command, therefore to a keypress.

Eg: Getting the length of the current selection:-
#+begin_src conf
:jseval window.getSelection().toString().length
#+end_src

However, I dont have the permission to run shell commands such as ~emacsclient~
So, unfortunately, I wont be able to make use of emacs's kill ring.
So, I wont be able to copy the selection in multiple formats.
So, this is also kinda a deadend.
*** COMMENT Userscript is a deadend
Userscript is different from a Greasemonkey script. Userscripts can be written in any language. I have chosen to write it in javascript because google provides a [[https://github.com/GoogleChromeLabs/text-fragments-polyfill][nice js library]] for fragment link creation.

**** COMMENT entrypoint
Userscripts can be called as follows:-
#+begin_src python
:spawn --userscript copy-url-to-selected-text-fragment.node.js
#+end_src
The above can also be bound to a keypress.

Qutebrowser userscripts are stored in the directory ~~/.config/qutebrowser/userscripts/~

Let me create it
#+begin_src bash :results output verbatim
mkdir ~/.config/qutebrowser/userscripts
#+end_src

Google provides a nice nodejs library that helps in turning selection text into the text fragment url format.
Hence, I have chosen to write my userscript in nodejs.
Let me install these that nodejs library
#+begin_src bash :results output verbatim :dir ~/.config/qutebrowser/userscripts/
npm i text-fragments-polyfill
#+end_src

#+RESULTS:
: 
: up to date, audited 2 packages in 3s
: 
: found 0 vulnerabilities

Unless I add ~"type": "module"~ into the package.json file, I wont be able to use ~import~ statements in my userscript. So do it by manually editing the package.json file generated by the above npm install command.

Whenever an userscript is run, qutebrowser passes certain environment variables to it.
Among these, QUTE_SELECTED_TEXT, QUTE_TITLE, QUTE_URL are useful for me here.
Lets write the main entrypoint of our userscript
#+begin_src js :tangle ~/.config/qutebrowser/userscripts/copy-url-to-selected-text-fragment.node.js :comments no :tangle-mode o755
#!/usr/bin/env node
<<js/Save to Emacs Kill Ring deprecated>>
<<js/Modify URL deprecated>>

const url = process.env.QUTE_URL;
const title = process.env.QUTE_TITLE;
const selected_text = process.env.QUTE_SELECTED_TEXT;

if (!(selected_text === undefined || selected_text.length === 0)) {
  // now valid selection is active
  const link = link_to_selected_text(url);
  save_to_emacs_kill_ring(link);
  save_to_emacs_kill_ring(`#+begin_quote ${link}\n${selected_text}\n#+end_quote`);
  save_to_emacs_kill_ring(selected_text);  
}
#+end_src

*Aside:-*
Knuth wouldnt insert org-targets uptop like that.
Instead, most likely, he would create an src block that accepts some text to be copied to emacs kill ring.

ie,
~¬´qute/save_to_emacs_kill_ring¬ª(url);~ etc

ie,
Knuth doesnt keep writing functions un-necessarily. He just writes global imperative code. This suits literate programming style better.

**** Lets modify an url into link to text fragment
Refer to how Google's chrome extension implements the text fragment functionality:-
[[https://github.com/GoogleChromeLabs/link-to-text-fragment/blob/main/content_script.js][link-to-text-fragment/content_script.js at main ¬∑ GoogleChromeLabs/link-to-text-fragment]]
Esp, read the ~const creatTextFragment~ function.

#+begin_src js :noweb-ref "js/Modify URL deprecated"
import { generateFragment } from 'text-fragments-polyfill/dist/fragment-generation-utils.js';

function link_to_selected_text(url0) {
  const result = generateFragment(window.getSelection());
  const status = result.status;
  if (status === 0) {
    const fragment = result.fragment;
    const prefix = fragment.prefix ?
          `${encodeURIComponent(fragment.prefix)}-,` :
          '';
    const suffix = fragment.suffix ?
          `,-${encodeURIComponent(fragment.suffix)}` :
          '';
    const textStart = encodeURIComponent(fragment.textStart);
    const textEnd = fragment.textEnd ?
          `,${encodeURIComponent(fragment.textEnd)}` :
          '';
    url0 = `${url0}:~:text=${prefix}${textStart}${textEnd}${suffix}`;
  } else {
    console.log("Couldnt convert url into link to selected text");

    const statusCodes = {
      1: 'INVALID_SELECTION: The selection provided could not be used.',
      // eslint-disable-next-line max-len
      2: 'AMBIGUOUS: No unique fragment could be identified for this selection.',
      3: 'TIMEOUT: Computation could not complete in time.',
      4: 'EXECUTION_FAILED: Unknown error.',
    };
    console.log(statusCodes[status]);
  }
  return url0;
}
#+end_src

*I have run into a dead end.*
~generateFragment~ expects its first argument to be the ~window.getSelection()~ object.
But, I dont have access to ~window~ in userscripts.

**** Talking to emacsclient

Trick to copying selection and url in three formats
I will add 3 items to the kill ring:-

1. Current text fragment url if selection is active, Current url if selection isnt active
2. If selection is active, selected text in the format
   ~begin_quote url <selected text> end_quote~
3. Above url in the org format ‚¶è‚¶èurl‚¶é‚¶èpage title‚¶é‚¶é
   Now, I can easily pick amongst the above three by calling C-y M-y

F9, M-w : insert quoted selected_text into kill ring and copy selected_text


For this, I need to call emacsclient inside my nodejs script to manipulate the kill ring.
The relevant elisp function is ~(kill-new STRING &optional REPLACE)~

Async methods are not preferred because they dont respect the order of insertion into the kill ring!
#+begin_src js :noweb-ref "js/Save to Emacs Kill Ring deprecated"
import { exec } from "child_process";

function save_to_emacs_kill_ring (text0) {
  //emacsclient gets confused if doublequotes and singlequotes arent escaped
  //lets escape doublequote. ie replace " with \"
  text0 = text0.replace(/"/g, '\\"');
  //lets escape singlequote. ie replace ' with \'
  text0 = text0.replace(/'/g, '\\\'');
    
  let elisp = `'(kill-new "`  + text0 + `")'`;
  let shell_cmd = `emacsclient --eval ${elisp}`;
  //console.log(elisp);
  //console.log(shell_cmd);

  exec(shell_cmd, (error, stdout, stderr) => {
    if (error) {
      console.log(`error: ${error.message}`);
      return;
    }
    if (stderr) {
      console.log(`stderr: ${stderr}`);
      return;
    }
    console.log(`copied ${text0} to kill-ring`);
  });
};
#+end_src

Sync method is fast enough for this usecase:-
#+begin_src js :noweb-ref "js/Save to Emacs Kill Ring deprecated"
import { execSync } from "child_process";

function save_to_emacs_kill_ring (text0) {
  let elisp = `'(kill-new "`  + text0 + `")'`;
  let shell_cmd = `emacsclient --eval ${elisp}`;
  execSync(shell_cmd, {timeout: 5000,});
  console.log(`Copied ${text0} to clipboard synchronously`)
};
#+end_src

*** COMMENT Userscript + qutejs library
^disabled because I moved on to an implementation that doesnt depend on this outdated qutejs npm library.

Userscript is different from a Greasemonkey script. Userscripts can be written in any language.

I have chosen to write it in javascript because Google provides a [[https://github.com/GoogleChromeLabs/text-fragments-polyfill][nice js library]] that helps in turning selection into the text fragment url format.

There is js library called qutejs that makes writing qutebrowser userscripts easier.
This library is required because it makes it easy to evaluate javascript in the same context as the current browser window.
ie, it kinda helps me easily run ~:jseval~ from my userscript.

So, I will be using two libraries named ~qutejs~ and ~text-fragments-polyfill~

**** entrypoint for userscript to copy link_to_selection
Invoking an userscript from keypress can be accomplished as follows:-
#+begin_src python
'spawn --userscript copy-url-to-selected-text-fragment.node.mjs'
#+end_src

Whenever an userscript is run, qutebrowser passes certain environment variables to it.
Among these, QUTE_SELECTED_TEXT, QUTE_TITLE, QUTE_URL are useful for me here.

Lets write the main entrypoint of our userscript. I had to create the directory =mkdir ~/.config/qutebrowser/userscripts/=
(Notice that if you are using guix, you need to ensure that =node= is installed for below shebang to work. Also, I need to ensure that =qutejs= npm library is available.)

This approach was brittle and slow. The npm library =qutejs= is 7yrs old.
Earlier this was tangled as ~:tangle ~/.config/qutebrowser/userscripts/copy-url-to-selected-text-fragment.node.mjs~
Have disabled it now.
#+begin_src js :tangle no
#!/usr/bin/env node

import qutejs from 'qutejs';

console.log("The script atleast entered");

qutejs.jseval([], function () {
  /*alert('Inside lambda passed to jseval');*/
  /* Create a new context, so that I can use this function multiple times on a tab */  
  if (true) {
      console.log("bla bla 1");
      <<Load prepare.js>>
      console.log("bla bla 2");
      <<Load fragment-generation-utils.js>>
      /*wait for 3 upto seconds for copying to complete*/
      setTimeout(3000); /*this function is defined inside fragment-generation-utils.js*/
      console.log("bla bla 3");

      <<Create Link and Copy it>>
      console.log("bla bla 4");
  }
});

console.log("bla bla 5");
#+end_src

Alternative solution 

**** Create Link and Copy it
#+begin_src js :noweb-ref "Create Link and Copy it"
let selection0 = window.getSelection();
const selected_text = selection0.toString();
console.log(selection0);
const result = generateFragment(selection0);
const status = result.status;

if (status === 0) {
  const fragment = result.fragment;
  const prefix = fragment.prefix ?
        `${encodeURIComponent(fragment.prefix)}-,` :
        '';
  const suffix = fragment.suffix ?
        `,-${encodeURIComponent(fragment.suffix)}` :
        '';
  const textStart = encodeURIComponent(fragment.textStart);
  const textEnd = fragment.textEnd ?
        `,${encodeURIComponent(fragment.textEnd)}` :
        '';

  const hash2 = window.location.hash ? window.location.hash : '#';
  
  const url2 = `${window.location.origin}${window.location.pathname}${window.location.search}${hash2}`;
  console.log("url2", url2);
  console.log("prefix", prefix);
  console.log("suffix", suffix);
  console.log("textStart", textStart);
  console.log("textEnd", textEnd);
  
  const link = `${url2}:~:text=${prefix}${textStart}${textEnd}${suffix}`;

  console.log("link", link);
  <<Copy selection and link to clipboard>>
  console.log("Successfully copied selection :)");
} else {
  console.log("Couldnt convert url into link to selected text. The selection = ");
  console.log(selection0);
  console.log(selection0.toString());
  
  const statusCodes = {
    1: 'INVALID_SELECTION: The selection provided could not be used.',
    2: 'AMBIGUOUS: No unique fragment could be identified for this selection.',
    3: 'TIMEOUT: Computation could not complete in time.',
    4: 'EXECUTION_FAILED: Unknown error.',
  };
  console.log(statusCodes[status]);
}
#+end_src
**** Copy to clipboard
source: https://stackoverflow.com/a/33928558
#+begin_src js :noweb-ref "Copy selection and link to clipboard"
var tocopy = '#+begin_quote ' + link + '\n' + selected_text + '\n#+end_quote\n';

if (navigator.clipboard) {
  navigator.clipboard.writeText(tocopy).then(function() {
    console.log('Async: Copying to clipboard was successful!');
  }, function(err) {
    console.error('Async: Could not copy text: ', err);
  });
} else {
  var textArea = document.createElement("textarea");
  textArea.value = tocopy;
  
  /* Avoid scrolling to bottom */
  textArea.style.top = "0";
  textArea.style.left = "0";
  textArea.style.position = "fixed";

  document.body.appendChild(textArea);
  textArea.focus();
  textArea.select();

  try {
    var successful = document.execCommand('copy');
    var msg = successful ? 'successful' : 'unsuccessful';
    console.log('Fallback: Copying text command was ' + msg);
  } catch (err) {
    console.error('Fallback: Oops, unable to copy', err);
  }

  document.body.removeChild(textArea);
}
#+end_src

I found that string interpolation is somewhat fragile in these js scripts for some reason. Hence, avoiding it in constructing ~tocopy~ string.

**** Google's two libraries
:PROPERTIES:
:VISIBILITY: FOLDED
:END:

I have copied these files from [[https://github.com/GoogleChromeLabs/link-to-text-fragment/][here]] without ever trying to understand them.
The only change I have made to them is that I have deleted all comments of the form ~// bla bla bla~ because they were causing problems.

#+begin_src js :noweb-ref "Load prepare.js"
const exports = {};
#+end_src

#+begin_src js :noweb-ref "Load fragment-generation-utils.js"
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setTimeout = exports.isValidRangeForFragmentGeneration = exports.generateFragment = exports.forTesting = exports.GenerateFragmentStatus = void 0;
/**
 ,* Copyright 2020 Google LLC
 ,*
 ,* Licensed under the Apache License, Version 2.0 (the "License");
 ,* you may not use this file except in compliance with the License.
 ,* You may obtain a copy of the License at
 ,*
 ,*     https:
 ,*
 ,* Unless required by applicable law or agreed to in writing, software
 ,* distributed under the License is distributed on an "AS IS" BASIS,
 ,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ,* See the License for the specific language governing permissions and
 ,* limitations under the License.
 ,*/

const BLOCK_ELEMENTS = ['ADDRESS', 'ARTICLE', 'ASIDE', 'BLOCKQUOTE', 'BR', 'DETAILS', 'DIALOG', 'DD', 'DIV', 'DL', 'DT', 'FIELDSET', 'FIGCAPTION', 'FIGURE', 'FOOTER', 'FORM', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HEADER', 'HGROUP', 'HR', 'LI', 'MAIN', 'NAV', 'OL', 'P', 'PRE', 'SECTION', 'TABLE', 'UL', 'TR', 'TH', 'TD', 'COLGROUP', 'COL', 'CAPTION', 'THEAD', 'TBODY', 'TFOOT'];

const BOUNDARY_CHARS = /[\t-\r -#%-\*,-\/:;\?@\[-\]_\{\}\x85\xA0\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/u;


const NON_BOUNDARY_CHARS = /[^\t-\r -#%-\*,-\/:;\?@\[-\]_\{\}\x85\xA0\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/u;

/**
 ,* Searches the document for a given text fragment.
 ,*
 ,* @param {TextFragment} textFragment - Text Fragment to highlight.
 ,* @param {Document} documentToProcess - document where to extract and mark
 ,*     fragments in.
 ,* @return {Ranges[]} - Zero or more ranges within the document corresponding
 ,*     to the fragment. If the fragment corresponds to more than one location
 ,*     in the document (i.e., is ambiguous) then the first two matches will be
 ,*     returned (regardless of how many more matches there may be in the
 ,*     document).
 ,*/

const processTextFragmentDirective = (textFragment, documentToProcess = document) => {
  const results = [];
  const searchRange = documentToProcess.createRange();
  searchRange.selectNodeContents(documentToProcess.body);
  while (!searchRange.collapsed && results.length < 2) {
    let potentialMatch;
    if (textFragment.prefix) {
      const prefixMatch = findTextInRange(textFragment.prefix, searchRange);
      if (prefixMatch == null) {
        break;
      }
      
      
      advanceRangeStartPastOffset(searchRange, prefixMatch.startContainer, prefixMatch.startOffset);

      
      
      
      const matchRange = documentToProcess.createRange();
      matchRange.setStart(prefixMatch.endContainer, prefixMatch.endOffset);
      matchRange.setEnd(searchRange.endContainer, searchRange.endOffset);
      advanceRangeStartToNonWhitespace(matchRange);
      if (matchRange.collapsed) {
        break;
      }
      potentialMatch = findTextInRange(textFragment.textStart, matchRange);
      
      
      if (potentialMatch == null) {
        break;
      }

      
      
      
      
      if (potentialMatch.compareBoundaryPoints(Range.START_TO_START, matchRange) !== 0) {
        continue;
      }
    } else {
      
      potentialMatch = findTextInRange(textFragment.textStart, searchRange);
      if (potentialMatch == null) {
        break;
      }
      advanceRangeStartPastOffset(searchRange, potentialMatch.startContainer, potentialMatch.startOffset);
    }
    if (textFragment.textEnd) {
      const textEndRange = documentToProcess.createRange();
      textEndRange.setStart(potentialMatch.endContainer, potentialMatch.endOffset);
      textEndRange.setEnd(searchRange.endContainer, searchRange.endOffset);

      
      
      
      
      
      let matchFound = false;

            
      while (!textEndRange.collapsed && results.length < 2) {
        const textEndMatch = findTextInRange(textFragment.textEnd, textEndRange);
        if (textEndMatch == null) {
          break;
        }
        advanceRangeStartPastOffset(textEndRange, textEndMatch.startContainer, textEndMatch.startOffset);
        potentialMatch.setEnd(textEndMatch.endContainer, textEndMatch.endOffset);
        if (textFragment.suffix) {
                    
          const suffixResult = checkSuffix(textFragment.suffix, potentialMatch, searchRange, documentToProcess);
          if (suffixResult === CheckSuffixResult.NO_SUFFIX_MATCH) {
            break;
          } else if (suffixResult === CheckSuffixResult.SUFFIX_MATCH) {
            matchFound = true;
            results.push(potentialMatch.cloneRange());
            continue;
          } else if (suffixResult === CheckSuffixResult.MISPLACED_SUFFIX) {
            continue;
          }
        } else {
                    
          matchFound = true;
          results.push(potentialMatch.cloneRange());
        }
      }
            
      if (!matchFound) {
        break;
      }
    } else if (textFragment.suffix) {
            
      const suffixResult = checkSuffix(textFragment.suffix, potentialMatch, searchRange, documentToProcess);
      if (suffixResult === CheckSuffixResult.NO_SUFFIX_MATCH) {
        break;
      } else if (suffixResult === CheckSuffixResult.SUFFIX_MATCH) {
        results.push(potentialMatch.cloneRange());
        advanceRangeStartPastOffset(searchRange, searchRange.startContainer, searchRange.startOffset);
        continue;
      } else if (suffixResult === CheckSuffixResult.MISPLACED_SUFFIX) {
        continue;
      }
    } else {
      results.push(potentialMatch.cloneRange());
    }
  }
  return results;
};

/**
 ,* Enum indicating the result of the checkSuffix function.
 ,*/
const CheckSuffixResult = {
  NO_SUFFIX_MATCH: 0,
    SUFFIX_MATCH: 1,
    MISPLACED_SUFFIX: 2 
};

/**
 ,* Checks to see if potentialMatch satisfies the suffix conditions of this
 ,* Text Fragment.
 ,* @param {String} suffix - the suffix text to find
 ,* @param {Range} potentialMatch - the Range containing the match text.
 ,* @param {Range} searchRange - the Range in which to search for |suffix|.
 ,*     Regardless of the start boundary of this Range, nothing appearing before
 ,*     |potentialMatch| will be considered.
 ,* @param {Document} documentToProcess - document where to extract and mark
 ,*     fragments in.
 ,* @return {CheckSuffixResult} - enum value indicating that potentialMatch
 ,*     should be accepted, that the search should continue, or that the search
 ,*     should halt.
 ,*/
const checkSuffix = (suffix, potentialMatch, searchRange, documentToProcess) => {
  const suffixRange = documentToProcess.createRange();
  suffixRange.setStart(potentialMatch.endContainer, potentialMatch.endOffset);
  suffixRange.setEnd(searchRange.endContainer, searchRange.endOffset);
  advanceRangeStartToNonWhitespace(suffixRange);
  const suffixMatch = findTextInRange(suffix, suffixRange);
    
  if (suffixMatch == null) {
    return CheckSuffixResult.NO_SUFFIX_MATCH;
  }

    
    if (suffixMatch.compareBoundaryPoints(Range.START_TO_START, suffixRange) !== 0) {
    return CheckSuffixResult.MISPLACED_SUFFIX;
  }
  return CheckSuffixResult.SUFFIX_MATCH;
};

/**
 ,* Sets the start of |range| to be the first boundary point after |offset| in
 ,* |node|--either at offset+1, or after the node.
 ,* @param {Range} range - the range to mutate
 ,* @param {Node} node - the node used to determine the new range start
 ,* @param {Number} offset - the offset immediately before the desired new
 ,*     boundary point
 ,*/
const advanceRangeStartPastOffset = (range, node, offset) => {
  try {
    range.setStart(node, offset + 1);
  } catch (err) {
    range.setStartAfter(node);
  }
};

/**
 ,* Modifies |range| to start at the next non-whitespace position.
 ,* @param {Range} range - the range to mutate
 ,*/
const advanceRangeStartToNonWhitespace = range => {
  const walker = makeTextNodeWalker(range);
  let node = walker.nextNode();
  while (!range.collapsed && node != null) {
    if (node !== range.startContainer) {
      range.setStart(node, 0);
    }
    if (node.textContent.length > range.startOffset) {
      const firstChar = node.textContent[range.startOffset];
      if (!firstChar.match(/\s/)) {
        return;
      }
    }
    try {
      range.setStart(node, range.startOffset + 1);
    } catch (err) {
      node = walker.nextNode();
      if (node == null) {
        range.collapse();
      } else {
        range.setStart(node, 0);
      }
    }
  }
};

/**
 ,* Creates a TreeWalker that traverses a range and emits visible text nodes in
 ,* the range.
 ,* @param {Range} range - Range to be traversed by the walker
 ,* @return {TreeWalker}
 ,*/
const makeTextNodeWalker = range => {
  const walker = document.createTreeWalker(range.commonAncestorContainer, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, node => {
    return acceptTextNodeIfVisibleInRange(node, range);
  });
  return walker;
};

/**
 ,* Helper function to calculate the visibility of a Node based on its CSS
 ,* computed style. This function does not take into account the visibility of
 ,* the node's ancestors so even if the node is visible according to its style
 ,* it might not be visible on the page if one of its ancestors is not visible.
 ,* @param {Node} node - the Node to evaluate
 ,* @return {Boolean} - true if the node is visible. A node will be visible if
 ,* its computed style meets all of the following criteria:
 ,*  - non zero height, width, height and opacity
 ,*  - visibility not hidden
 ,*  - display not none
 ,*/
const isNodeVisible = node => {
    
  let elt = node;
  while (elt != null && !(elt instanceof HTMLElement)) elt = elt.parentNode;
  if (elt != null) {
    const nodeStyle = window.getComputedStyle(elt);
        if (nodeStyle.visibility === 'hidden' || nodeStyle.display === 'none' || nodeStyle.height === 0 || nodeStyle.width === 0 || nodeStyle.opacity === 0) {
      return false;
    }
  }
  return true;
};

/**
 ,* Filter function for use with TreeWalkers. Rejects nodes that aren't in the
 ,* given range or aren't visible.
 ,* @param {Node} node - the Node to evaluate
 ,* @param {Range|Undefined} range - the range in which node must fall. Optional;
 ,*     if null, the range check is skipped.
 ,* @return {NodeFilter} - FILTER_ACCEPT or FILTER_REJECT, to be passed along to
 ,*     a TreeWalker.
 ,*/
const acceptNodeIfVisibleInRange = (node, range) => {
  if (range != null && !range.intersectsNode(node)) return NodeFilter.FILTER_REJECT;
  return isNodeVisible(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
};

/**
 ,* Filter function for use with TreeWalkers. Accepts only visible text nodes
 ,* that are in the given range. Other types of nodes visible in the given range
 ,* are skipped so a TreeWalker using this filter function still visits text
 ,* nodes in the node's subtree.
 ,* @param {Node} node - the Node to evaluate
 ,* @param {Range} range - the range in which node must fall. Optional;
 ,*     if null, the range check is skipped/
 ,* @return {NodeFilter} - NodeFilter value to be passed along to a TreeWalker.
 ,* Values returned:
 ,*  - FILTER_REJECT: Node not in range or not visible.
 ,*  - FILTER_SKIP: Non Text Node visible and in range
 ,*  - FILTER_ACCEPT: Text Node visible and in range
 ,*/
const acceptTextNodeIfVisibleInRange = (node, range) => {
  if (range != null && !range.intersectsNode(node)) return NodeFilter.FILTER_REJECT;
  if (!isNodeVisible(node)) {
    return NodeFilter.FILTER_REJECT;
  }
  return node.nodeType === Node.TEXT_NODE ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
};

/**
 ,* Extracts all the text nodes within the given range.
 ,* @param {Node} root - the root node in which to search
 ,* @param {Range} range - a range restricting the scope of extraction
 ,* @return {Array<String[]>} - a list of lists of text nodes, in document order.
 ,*     Lists represent block boundaries; i.e., two nodes appear in the same list
 ,*     iff there are no block element starts or ends in between them.
 ,*/
const getAllTextNodes = (root, range) => {
  const blocks = [];
  let tmp = [];
  const nodes = Array.from(getElementsIn(root, node => {
    return acceptNodeIfVisibleInRange(node, range);
  }));
  for (const node of nodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      tmp.push(node);
    } else if (node instanceof HTMLElement && BLOCK_ELEMENTS.includes(node.tagName) && tmp.length > 0) {
            
      blocks.push(tmp);
      tmp = [];
    }
  }
  if (tmp.length > 0) blocks.push(tmp);
  return blocks;
};

/**
 ,* Returns the textContent of all the textNodes and normalizes strings by
 ,* replacing duplicated spaces with single space.
 ,* @param {Node[]} nodes - TextNodes to get the textContent from.
 ,* @param {Number} startOffset - Where to start in the first TextNode.
 ,* @param {Number|undefined} endOffset Where to end in the last TextNode.
 ,* @return {string} Entire text content of all the nodes, with spaces
 ,*     normalized.
 ,*/
const getTextContent = (nodes, startOffset, endOffset) => {
  let str = '';
  if (nodes.length === 1) {
    str = nodes[0].textContent.substring(startOffset, endOffset);
  } else {
    str = nodes[0].textContent.substring(startOffset) + nodes.slice(1, -1).reduce((s, n) => s + n.textContent, '') + nodes.slice(-1)[0].textContent.substring(0, endOffset);
  }
  return str.replace(/[\t\n\r ]+/g, ' ');
};

/**
 ,* @callback ElementFilterFunction
 ,* @param {HTMLElement} element - Node to accept, reject or skip.
 ,* @returns {number} Either NodeFilter.FILTER_ACCEPT, NodeFilter.FILTER_REJECT
 ,*     or NodeFilter.FILTER_SKIP.
 ,*/

/**
 ,* Returns all nodes inside root using the provided filter.
 ,* @generator
 ,* @param {Node} root - Node where to start the TreeWalker.
 ,* @param {ElementFilterFunction} filter - Filter provided to the TreeWalker's
 ,*     acceptNode filter.
 ,* @yield {HTMLElement} All elements that were accepted by filter.
 ,*/
function* getElementsIn(root, filter) {
  const treeWalker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, {
    acceptNode: filter
  });
  const finishedSubtrees = new Set();
  while (forwardTraverse(treeWalker, finishedSubtrees) !== null) {
    yield treeWalker.currentNode;
  }
}

/**
 ,* Returns a range pointing to the first instance of |query| within |range|.
 ,* @param {String} query - the string to find
 ,* @param {Range} range - the range in which to search
 ,* @return {Range|Undefined} - The first found instance of |query| within
 ,*     |range|.
 ,*/
const findTextInRange = (query, range) => {
  const textNodeLists = getAllTextNodes(range.commonAncestorContainer, range);
  const segmenter = makeNewSegmenter();
  for (const list of textNodeLists) {
    const found = findRangeFromNodeList(query, range, list, segmenter);
    if (found !== undefined) return found;
  }
  return undefined;
};

/**
 ,* Finds a range pointing to the first instance of |query| within |range|,
 ,* searching over the text contained in a list |nodeList| of relevant textNodes.
 ,* @param {String} query - the string to find
 ,* @param {Range} range - the range in which to search
 ,* @param {Node[]} textNodes - the visible text nodes within |range|
 ,* @param {Intl.Segmenter} [segmenter] - a segmenter to be used for finding word
 ,*     boundaries, if supported
 ,* @return {Range} - the found range, or undefined if no such range could be
 ,*     found
 ,*/
const findRangeFromNodeList = (query, range, textNodes, segmenter) => {
  if (!query || !range || !(textNodes || []).length) return undefined;
  const data = normalizeString(getTextContent(textNodes, 0, undefined));
  const normalizedQuery = normalizeString(query);
  let searchStart = textNodes[0] === range.startNode ? range.startOffset : 0;
  let start;
  let end;
  while (searchStart < data.length) {
    const matchIndex = data.indexOf(normalizedQuery, searchStart);
    if (matchIndex === -1) return undefined;
    if (isWordBounded(data, matchIndex, normalizedQuery.length, segmenter)) {
      start = getBoundaryPointAtIndex(matchIndex, textNodes, /* isEnd=*/false);
      end = getBoundaryPointAtIndex(matchIndex + normalizedQuery.length, textNodes, /* isEnd=*/true);
    }
    if (start != null && end != null) {
      const foundRange = new Range();
      foundRange.setStart(start.node, start.offset);
      foundRange.setEnd(end.node, end.offset);

            if (range.compareBoundaryPoints(Range.START_TO_START, foundRange) <= 0 && range.compareBoundaryPoints(Range.END_TO_END, foundRange) >= 0) {
        return foundRange;
      }
    }
    searchStart = matchIndex + 1;
  }
  return undefined;
};

/**
 ,* Provides the data needed for calling setStart/setEnd on a Range.
 ,* @typedef {Object} BoundaryPoint
 ,* @property {Node} node
 ,* @property {Number} offset
 ,*/

/**
 ,* Generates a boundary point pointing to the given text position.
 ,* @param {Number} index - the text offset indicating the start/end of a
 ,*     substring of the concatenated, normalized text in |textNodes|
 ,* @param {Node[]} textNodes - the text Nodes whose contents make up the search
 ,*     space
 ,* @param {bool} isEnd - indicates whether the offset is the start or end of the
 ,*     substring
 ,* @return {BoundaryPoint} - a boundary point suitable for setting as the start
 ,*     or end of a Range, or undefined if it couldn't be computed.
 ,*/
const getBoundaryPointAtIndex = (index, textNodes, isEnd) => {
  let counted = 0;
  let normalizedData;
  for (let i = 0; i < textNodes.length; i++) {
    const node = textNodes[i];
    if (!normalizedData) normalizedData = normalizeString(node.data);
    let nodeEnd = counted + normalizedData.length;
    if (isEnd) nodeEnd += 1;
    if (nodeEnd > index) {
            
      const normalizedOffset = index - counted;
      let denormalizedOffset = Math.min(index - counted, node.data.length);

            
      const targetSubstring = isEnd ? normalizedData.substring(0, normalizedOffset) : normalizedData.substring(normalizedOffset);
      let candidateSubstring = isEnd ? normalizeString(node.data.substring(0, denormalizedOffset)) : normalizeString(node.data.substring(denormalizedOffset));

            
            
      const direction = (isEnd ? -1 : 1) * (targetSubstring.length > candidateSubstring.length ? -1 : 1);
      while (denormalizedOffset >= 0 && denormalizedOffset <= node.data.length) {
        if (candidateSubstring.length === targetSubstring.length) {
          return {
            node: node,
            offset: denormalizedOffset
          };
        }
        denormalizedOffset += direction;
        candidateSubstring = isEnd ? normalizeString(node.data.substring(0, denormalizedOffset)) : normalizeString(node.data.substring(denormalizedOffset));
      }
    }
    counted += normalizedData.length;
    if (i + 1 < textNodes.length) {
            
            const nextNormalizedData = normalizeString(textNodes[i + 1].data);
      if (normalizedData.slice(-1) === ' ' && nextNormalizedData.slice(0, 1) === ' ') {
        counted -= 1;
      }
            
      normalizedData = nextNormalizedData;
    }
  }
  return undefined;
};

/**
 ,* Checks if a substring is word-bounded in the context of a longer string.
 ,*
 ,* If an Intl.Segmenter is provided for locale-specific segmenting, it will be
 ,* used for this check. This is the most desirable option, but not supported in
 ,* all browsers.
 ,*
 ,* If one is not provided, a heuristic will be applied,
 ,* returning true iff:
 ,*  - startPos == 0 OR char before start is a boundary char, AND
 ,*  - length indicates end of string OR char after end is a boundary char
 ,* Where boundary chars are whitespace/punctuation defined in the const above.
 ,* This causes the known issue that some languages, notably Japanese, only match
 ,* at the level of roughly a full clause or sentence, rather than a word.
 ,*
 ,* @param {String} text - the text to search
 ,* @param {Number} startPos - the index of the start of the substring
 ,* @param {Number} length - the length of the substring
 ,* @param {Intl.Segmenter} [segmenter] - a segmenter to be used for finding word
 ,*     boundaries, if supported
 ,* @return {bool} - true iff startPos and length point to a word-bounded
 ,*     substring of |text|.
 ,*/
const isWordBounded = (text, startPos, length, segmenter) => {
  if (startPos < 0 || startPos >= text.length || length <= 0 || startPos + length > text.length) {
    return false;
  }
  if (segmenter) {
        

    const segments = segmenter.segment(text);
    const startSegment = segments.containing(startPos);
    if (!startSegment) return false;
        
        if (startSegment.isWordLike && startSegment.index != startPos) return false;

        const endPos = startPos + length;
    const endSegment = segments.containing(endPos);

        
        
        
        if (endSegment && endSegment.isWordLike && endSegment.index != endPos) return false;
  } else {
        

        if (text[startPos].match(BOUNDARY_CHARS)) {
      ++startPos;
      --length;
      if (!length) {
        return false;
      }
    }

        if (text[startPos + length - 1].match(BOUNDARY_CHARS)) {
      --length;
      if (!length) {
        return false;
      }
    }
    if (startPos !== 0 && !text[startPos - 1].match(BOUNDARY_CHARS)) return false;
    if (startPos + length !== text.length && !text[startPos + length].match(BOUNDARY_CHARS)) return false;
  }
  return true;
};

/**
 ,* @param {String} str - a string to be normalized
 ,* @return {String} - a normalized version of |str| with all consecutive
 ,*     whitespace chars converted to a single ' ' and all diacriticals removed
 ,*     (e.g., '√©' -> 'e').
 ,*/
const normalizeString = str => {
    
    
  return (str || '').normalize('NFKD').replace(/\s+/g, ' ').replace(/[\u0300-\u036f]/g, '').toLowerCase();
};

/**
 ,* @return {Intl.Segmenter|undefined} - a segmenter object suitable for finding
 ,*     word boundaries. Returns undefined on browsers/platforms that do not yet
 ,*     support the Intl.Segmenter API.
 ,*/
const makeNewSegmenter = () => {
  if (Intl.Segmenter) {
    let lang = document.documentElement.lang;
    if (!lang) {
      lang = navigator.languages;
    }
    return new Intl.Segmenter(lang, {
      granularity: 'word'
    });
  }
  return undefined;
};

/**
 ,* Performs traversal on a TreeWalker, visiting each subtree in document order.
 ,* When visiting a subtree not already visited (its root not in finishedSubtrees
 ,* ), first the root is emitted then the subtree is traversed, then the root is
 ,* emitted again and then the next subtree in document order is visited.
 ,*
 ,* Subtree's roots are emitted twice to signal the beginning and ending of
 ,* element nodes. This is useful for ensuring the ends of block boundaries are
 ,* found.
 ,* @param {TreeWalker} walker - the TreeWalker to be traversed
 ,* @param {Set} finishedSubtrees - set of subtree roots already visited
 ,* @return {Node} - next node in the traversal
 ,*/
const forwardTraverse = (walker, finishedSubtrees) => {
    
  if (!finishedSubtrees.has(walker.currentNode)) {
    const firstChild = walker.firstChild();
    if (firstChild !== null) {
      return firstChild;
    }
  }

    const nextSibling = walker.nextSibling();
  if (nextSibling !== null) {
    return nextSibling;
  }

    const parent = walker.parentNode();
  if (parent !== null) {
    finishedSubtrees.add(parent);
  }
  return parent;
};

/**
 ,* Performs backwards traversal on a TreeWalker, visiting each subtree in
 ,* backwards document order. When visiting a subtree not already visited (its
 ,* root not in finishedSubtrees ), first the root is emitted then the subtree is
 ,* backward traversed, then the root is emitted again and then the previous
 ,* subtree in document order is visited.
 ,*
 ,* Subtree's roots are emitted twice to signal the beginning and ending of
 ,* element nodes. This is useful for ensuring  block boundaries are found.
 ,* @param {TreeWalker} walker - the TreeWalker to be traversed
 ,* @param {Set} finishedSubtrees - set of subtree roots already visited
 ,* @return {Node} - next node in the backwards traversal
 ,*/
const backwardTraverse = (walker, finishedSubtrees) => {
    
  if (!finishedSubtrees.has(walker.currentNode)) {
    const lastChild = walker.lastChild();
    if (lastChild !== null) {
      return lastChild;
    }
  }

    const previousSibling = walker.previousSibling();
  if (previousSibling !== null) {
    return previousSibling;
  }

    const parent = walker.parentNode();
  if (parent !== null) {
    finishedSubtrees.add(parent);
  }
  return parent;
};

/**
 ,* Should only be used by other files in this directory.
 ,*/
const internal = {
  BLOCK_ELEMENTS: BLOCK_ELEMENTS,
  BOUNDARY_CHARS: BOUNDARY_CHARS,
  NON_BOUNDARY_CHARS: NON_BOUNDARY_CHARS,
  acceptNodeIfVisibleInRange: acceptNodeIfVisibleInRange,
  normalizeString: normalizeString,
  makeNewSegmenter: makeNewSegmenter,
  forwardTraverse: forwardTraverse,
  backwardTraverse: backwardTraverse,
  makeTextNodeWalker: makeTextNodeWalker,
  isNodeVisible: isNodeVisible
};


if (typeof goog !== 'undefined') {
    goog.declareModuleId('googleChromeLabs.textFragmentPolyfill.textFragmentUtils');
  }

/**
 ,* Copyright 2020 Google LLC
 ,*
 ,* Licensed under the Apache License, Version 2.0 (the "License");
 ,* you may not use this file except in compliance with the License.
 ,* You may obtain a copy of the License at
 ,*
 ,*     https: *
 ,* Unless required by applicable law or agreed to in writing, software
 ,* distributed under the License is distributed on an "AS IS" BASIS,
 ,* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ,* See the License for the specific language governing permissions and
 ,* limitations under the License.
 ,*/

const MAX_EXACT_MATCH_LENGTH = 300;
const MIN_LENGTH_WITHOUT_CONTEXT = 20;
const ITERATIONS_BEFORE_ADDING_CONTEXT = 1;
const WORDS_TO_ADD_FIRST_ITERATION = 3;
const WORDS_TO_ADD_SUBSEQUENT_ITERATIONS = 1;
const TRUNCATE_RANGE_CHECK_CHARS = 10000;
const MAX_DEPTH = 500;

let timeoutDurationMs = 500;
let t0; 
/**
 ,* Allows overriding the max runtime to specify a different interval. Fragment
 ,* generation will halt and throw an error after this amount of time.
 ,* @param {Number} newTimeoutDurationMs - the desired timeout length, in ms.
 ,*/
const setTimeout = newTimeoutDurationMs => {
  timeoutDurationMs = newTimeoutDurationMs;
};

/**
 ,* Enum indicating the success, or failure reason, of generateFragment.
 ,*/
exports.setTimeout = setTimeout;
const GenerateFragmentStatus = {
  SUCCESS: 0,
    INVALID_SELECTION: 1,
    AMBIGUOUS: 2,
    TIMEOUT: 3,
    EXECUTION_FAILED: 4 
};

/**
 ,* @typedef {Object} GenerateFragmentResult
 ,* @property {GenerateFragmentStatus} status
 ,* @property {TextFragment} [fragment]
 ,*/

/**
 ,* Attempts to generate a fragment, suitable for formatting and including in a
 ,* URL, which will highlight the given selection upon opening.
 ,* @param {Selection} selection - a Selection object, the result of
 ,*     window.getSelection
 ,* @param {Date} [startTime] - the time when generation began, for timeout
 ,*     purposes. Defaults to current timestamp.
 ,* @return {GenerateFragmentResult}
 ,*/
exports.GenerateFragmentStatus = GenerateFragmentStatus;
const generateFragment = (selection, startTime = Date.now()) => {
  try {
    return doGenerateFragment(selection, startTime);
  } catch (err) {
    if (err.isTimeout) {
      return {
        status: GenerateFragmentStatus.TIMEOUT
      };
    } else {
      return {
        status: GenerateFragmentStatus.EXECUTION_FAILED
      };
    }
  }
};

/**
 ,* Checks whether fragment generation can be attempted for a given range. This
 ,* checks a handful of simple conditions: the range must be nonempty, not inside
 ,* an <input>, etc. A true return is not a guarantee that fragment generation
 ,* will succeed; instead, this is a way to quickly rule out generation in cases
 ,* where a failure is predictable.
 ,* @param {Range} range
 ,* @return {boolean} - true if fragment generation may proceed; false otherwise.
 ,*/
exports.generateFragment = generateFragment;
const isValidRangeForFragmentGeneration = range => {
    
    
    if (!range.toString().substring(0, TRUNCATE_RANGE_CHECK_CHARS).match(internal.NON_BOUNDARY_CHARS)) {
    return false;
  }

    try {
    if (range.startContainer.ownerDocument.defaultView !== window.top) {
      return false;
    }
  } catch {
        
    return false;
  }

    
  let node = range.commonAncestorContainer;
  let numIterations = 0;
  while (node) {
    if (node.nodeType == Node.ELEMENT_NODE) {
      if (['TEXTAREA', 'INPUT'].includes(node.tagName)) {
        return false;
      }
      const editable = node.attributes.getNamedItem('contenteditable');
      if (editable && editable.value !== 'false') {
        return false;
      }

            
      numIterations++;
      if (numIterations >= MAX_DEPTH) {
        return false;
      }
    }
    node = node.parentNode;
  }
  return true;
};

/* eslint-disable valid-jsdoc */
/**
 ,* @see {@link generateFragment} - this method wraps the error-throwing portions
 ,*     of that method.
 ,* @throws {Error} - Will throw if computation takes longer than the accepted
 ,*     timeout length.
 ,*/
exports.isValidRangeForFragmentGeneration = isValidRangeForFragmentGeneration;
const doGenerateFragment = (selection, startTime) => {
  recordStartTime(startTime);
  let range;
  try {
    range = selection.getRangeAt(0);
  } catch {
    return {
      status: GenerateFragmentStatus.INVALID_SELECTION
    };
  }
  expandRangeStartToWordBound(range);
  expandRangeEndToWordBound(range);
    
    
    
  const rangeBeforeShrinking = range.cloneRange();
  moveRangeEdgesToTextNodes(range);
  if (range.collapsed) {
    return {
      status: GenerateFragmentStatus.INVALID_SELECTION
    };
  }
  let factory;
  if (canUseExactMatch(range)) {
    const exactText = internal.normalizeString(range.toString());
    const fragment = {
      textStart: exactText
    };
        
    if (exactText.length >= MIN_LENGTH_WITHOUT_CONTEXT && isUniquelyIdentifying(fragment)) {
      return {
        status: GenerateFragmentStatus.SUCCESS,
        fragment: fragment
      };
    }
    factory = new FragmentFactory().setExactTextMatch(exactText);
  } else {
        
        const startSearchSpace = getSearchSpaceForStart(range);
    const endSearchSpace = getSearchSpaceForEnd(range);
    if (startSearchSpace && endSearchSpace) {
            
      factory = new FragmentFactory().setStartAndEndSearchSpace(startSearchSpace, endSearchSpace);
    } else {
            
            
      factory = new FragmentFactory().setSharedSearchSpace(range.toString().trim());
    }
  }
  const prefixRange = document.createRange();
  prefixRange.selectNodeContents(document.body);
  const suffixRange = prefixRange.cloneRange();
  prefixRange.setEnd(rangeBeforeShrinking.startContainer, rangeBeforeShrinking.startOffset);
  suffixRange.setStart(rangeBeforeShrinking.endContainer, rangeBeforeShrinking.endOffset);
  const prefixSearchSpace = getSearchSpaceForEnd(prefixRange);
  const suffixSearchSpace = getSearchSpaceForStart(suffixRange);
  if (prefixSearchSpace || suffixSearchSpace) {
    factory.setPrefixAndSuffixSearchSpace(prefixSearchSpace, suffixSearchSpace);
  }
  factory.useSegmenter(internal.makeNewSegmenter());
  let didEmbiggen = false;
  do {
    checkTimeout();
    didEmbiggen = factory.embiggen();
    const fragment = factory.tryToMakeUniqueFragment();
    if (fragment != null) {
      return {
        status: GenerateFragmentStatus.SUCCESS,
        fragment: fragment
      };
    }
  } while (didEmbiggen);
  return {
    status: GenerateFragmentStatus.AMBIGUOUS
  };
};

/**
 ,* @throws {Error} - if the timeout duration has been exceeded, an error will
 ,*     be thrown so that execution can be halted.
 ,*/
const checkTimeout = () => {
    if (timeoutDurationMs === null) {
    return;
  }
  const delta = Date.now() - t0;
  if (delta > timeoutDurationMs) {
    const timeoutError = new Error(`Fragment generation timed out after ${delta} ms.`);
    timeoutError.isTimeout = true;
    throw timeoutError;
  }
};

/**
 ,* Call at the start of fragment generation to set the baseline for timeout
 ,* checking.
 ,* @param {Date} newStartTime - the timestamp when fragment generation began
 ,*/
const recordStartTime = newStartTime => {
  t0 = newStartTime;
};

/**
 ,* Finds the search space for parameters when using range or suffix match.
 ,* This is the text from the start of the range to the first block boundary,
 ,* trimmed to remove any leading/trailing whitespace characters.
 ,* @param {Range} range - the range which will be highlighted.
 ,* @return {String|Undefined} - the text which may be used for constructing a
 ,*     textStart parameter identifying this range. Will return undefined if no
 ,*     block boundaries are found inside this range, or if all the candidate
 ,*     ranges were empty (or included only whitespace characters).
 ,*/
const getSearchSpaceForStart = range => {
  let node = getFirstNodeForBlockSearch(range);
  const walker = makeWalkerForNode(node, range.endContainer);
  if (!walker) {
    return undefined;
  }
  const finishedSubtrees = new Set();
    
  if (range.startContainer.nodeType === Node.ELEMENT_NODE && range.startOffset === range.startContainer.childNodes.length) {
    finishedSubtrees.add(range.startContainer);
  }
  const origin = node;
  const textAccumulator = new BlockTextAccumulator(range, true);
    const tempRange = range.cloneRange();
  while (!tempRange.collapsed && node != null) {
    checkTimeout();
        
    if (node.contains(origin)) {
      tempRange.setStartAfter(node);
    } else {
      tempRange.setStartBefore(node);
    }
        
    textAccumulator.appendNode(node);

        
    if (textAccumulator.textInBlock !== null) {
      return textAccumulator.textInBlock;
    }
    node = internal.forwardTraverse(walker, finishedSubtrees);
  }
  return undefined;
};

/**
 ,* Finds the search space for parameters when using range or prefix match.
 ,* This is the text from the last block boundary to the end of the range,
 ,* trimmed to remove any leading/trailing whitespace characters.
 ,* @param {Range} range - the range which will be highlighted.
 ,* @return {String|Undefined} - the text which may be used for constructing a
 ,*     textEnd parameter identifying this range. Will return undefined if no
 ,*     block boundaries are found inside this range, or if all the candidate
 ,*     ranges were empty (or included only whitespace characters).
 ,*/
const getSearchSpaceForEnd = range => {
  let node = getLastNodeForBlockSearch(range);
  const walker = makeWalkerForNode(node, range.startContainer);
  if (!walker) {
    return undefined;
  }
  const finishedSubtrees = new Set();
    
  if (range.endContainer.nodeType === Node.ELEMENT_NODE && range.endOffset === 0) {
    finishedSubtrees.add(range.endContainer);
  }
  const origin = node;
  const textAccumulator = new BlockTextAccumulator(range, false);

    const tempRange = range.cloneRange();
  while (!tempRange.collapsed && node != null) {
    checkTimeout();
        
    if (node.contains(origin)) {
      tempRange.setEnd(node, 0);
    } else {
      tempRange.setEndAfter(node);
    }

        
    textAccumulator.appendNode(node);

        
    if (textAccumulator.textInBlock !== null) {
      return textAccumulator.textInBlock;
    }
    node = internal.backwardTraverse(walker, finishedSubtrees);
  }
  return undefined;
};

/**
 ,* Helper class for constructing range-based fragments for selections that cross
 ,* block boundaries.
 ,*/
const FragmentFactory = class {
  /**
   ,* Initializes the basic state of the factory. Users should then call exactly
   ,* one of setStartAndEndSearchSpace, setSharedSearchSpace, or
   ,* setExactTextMatch, and optionally setPrefixAndSuffixSearchSpace.
   ,*/
  constructor() {
    this.Mode = {
      ALL_PARTS: 1,
      SHARED_START_AND_END: 2,
      CONTEXT_ONLY: 3
    };
    this.startOffset = null;
    this.endOffset = null;
    this.prefixOffset = null;
    this.suffixOffset = null;
    this.prefixSearchSpace = '';
    this.backwardsPrefixSearchSpace = '';
    this.suffixSearchSpace = '';
    this.numIterations = 0;
  }

  /**
   ,* Generates a fragment based on the current state, then tests it for
   ,* uniqueness.
   ,* @return {TextFragment|Undefined} - a text fragment if the current state is
   ,*     uniquely identifying, or undefined if the current state is ambiguous.
   ,*/
  tryToMakeUniqueFragment() {
    let fragment;
    if (this.mode === this.Mode.CONTEXT_ONLY) {
      fragment = {
        textStart: this.exactTextMatch
      };
    } else {
      fragment = {
        textStart: this.getStartSearchSpace().substring(0, this.startOffset).trim(),
        textEnd: this.getEndSearchSpace().substring(this.endOffset).trim()
      };
    }
    if (this.prefixOffset != null) {
      const prefix = this.getPrefixSearchSpace().substring(this.prefixOffset).trim();
      if (prefix) {
        fragment.prefix = prefix;
      }
    }
    if (this.suffixOffset != null) {
      const suffix = this.getSuffixSearchSpace().substring(0, this.suffixOffset).trim();
      if (suffix) {
        fragment.suffix = suffix;
      }
    }
    return isUniquelyIdentifying(fragment) ? fragment : undefined;
  }

  /**
   ,* Shifts the current state such that the candidates for textStart and textEnd
   ,* represent more of the possible search spaces.
   ,* @return {boolean} - true if the desired expansion occurred; false if the
   ,*     entire search space has been consumed and no further attempts can be
   ,*     made.
   ,*/
  embiggen() {
    let canExpandRange = true;
    if (this.mode === this.Mode.SHARED_START_AND_END) {
      if (this.startOffset >= this.endOffset) {
                
        canExpandRange = false;
      }
    } else if (this.mode === this.Mode.ALL_PARTS) {
            
      if (this.startOffset === this.getStartSearchSpace().length && this.backwardsEndOffset() === this.getEndSearchSpace().length) {
        canExpandRange = false;
      }
    } else if (this.mode === this.Mode.CONTEXT_ONLY) {
      canExpandRange = false;
    }
    if (canExpandRange) {
      const desiredIterations = this.getNumberOfRangeWordsToAdd();
      if (this.startOffset < this.getStartSearchSpace().length) {
        let i = 0;
        if (this.getStartSegments() != null) {
          while (i < desiredIterations && this.startOffset < this.getStartSearchSpace().length) {
            this.startOffset = this.getNextOffsetForwards(this.getStartSegments(), this.startOffset, this.getStartSearchSpace());
            i++;
          }
        } else {
                    
                    let oldStartOffset = this.startOffset;
          do {
            checkTimeout();
            const newStartOffset = this.getStartSearchSpace().substring(this.startOffset + 1).search(internal.BOUNDARY_CHARS);
            if (newStartOffset === -1) {
              this.startOffset = this.getStartSearchSpace().length;
            } else {
              this.startOffset = this.startOffset + 1 + newStartOffset;
            }
                        if (this.getStartSearchSpace().substring(oldStartOffset, this.startOffset).search(internal.NON_BOUNDARY_CHARS) !== -1) {
              oldStartOffset = this.startOffset;
              i++;
            }
          } while (this.startOffset < this.getStartSearchSpace().length && i < desiredIterations);
        }

                if (this.mode === this.Mode.SHARED_START_AND_END) {
          this.startOffset = Math.min(this.startOffset, this.endOffset);
        }
      }
      if (this.backwardsEndOffset() < this.getEndSearchSpace().length) {
        let i = 0;
        if (this.getEndSegments() != null) {
          while (i < desiredIterations && this.endOffset > 0) {
            this.endOffset = this.getNextOffsetBackwards(this.getEndSegments(), this.endOffset);
            i++;
          }
        } else {
                    
          let oldBackwardsEndOffset = this.backwardsEndOffset();
          do {
            checkTimeout();
            const newBackwardsOffset = this.getBackwardsEndSearchSpace().substring(this.backwardsEndOffset() + 1).search(internal.BOUNDARY_CHARS);
            if (newBackwardsOffset === -1) {
              this.setBackwardsEndOffset(this.getEndSearchSpace().length);
            } else {
              this.setBackwardsEndOffset(this.backwardsEndOffset() + 1 + newBackwardsOffset);
            }
                        if (this.getBackwardsEndSearchSpace().substring(oldBackwardsEndOffset, this.backwardsEndOffset()).search(internal.NON_BOUNDARY_CHARS) !== -1) {
              oldBackwardsEndOffset = this.backwardsEndOffset();
              i++;
            }
          } while (this.backwardsEndOffset() < this.getEndSearchSpace().length && i < desiredIterations);
        }
                if (this.mode === this.Mode.SHARED_START_AND_END) {
          this.endOffset = Math.max(this.startOffset, this.endOffset);
        }
      }
    }
    let canExpandContext = false;
    if (!canExpandRange || this.startOffset + this.backwardsEndOffset() < MIN_LENGTH_WITHOUT_CONTEXT || this.numIterations >= ITERATIONS_BEFORE_ADDING_CONTEXT) {
            if (this.backwardsPrefixOffset() != null && this.backwardsPrefixOffset() !== this.getPrefixSearchSpace().length || this.suffixOffset != null && this.suffixOffset !== this.getSuffixSearchSpace().length) {
        canExpandContext = true;
      }
    }
    if (canExpandContext) {
      const desiredIterations = this.getNumberOfContextWordsToAdd();
      if (this.backwardsPrefixOffset() < this.getPrefixSearchSpace().length) {
        let i = 0;
        if (this.getPrefixSegments() != null) {
          while (i < desiredIterations && this.prefixOffset > 0) {
            this.prefixOffset = this.getNextOffsetBackwards(this.getPrefixSegments(), this.prefixOffset);
            i++;
          }
        } else {
                    
          let oldBackwardsPrefixOffset = this.backwardsPrefixOffset();
          do {
            checkTimeout();
            const newBackwardsPrefixOffset = this.getBackwardsPrefixSearchSpace().substring(this.backwardsPrefixOffset() + 1).search(internal.BOUNDARY_CHARS);
            if (newBackwardsPrefixOffset === -1) {
              this.setBackwardsPrefixOffset(this.getBackwardsPrefixSearchSpace().length);
            } else {
              this.setBackwardsPrefixOffset(this.backwardsPrefixOffset() + 1 + newBackwardsPrefixOffset);
            }
                        if (this.getBackwardsPrefixSearchSpace().substring(oldBackwardsPrefixOffset, this.backwardsPrefixOffset()).search(internal.NON_BOUNDARY_CHARS) !== -1) {
              oldBackwardsPrefixOffset = this.backwardsPrefixOffset();
              i++;
            }
          } while (this.backwardsPrefixOffset() < this.getPrefixSearchSpace().length && i < desiredIterations);
        }
      }
      if (this.suffixOffset < this.getSuffixSearchSpace().length) {
        let i = 0;
        if (this.getSuffixSegments() != null) {
          while (i < desiredIterations && this.suffixOffset < this.getSuffixSearchSpace().length) {
            this.suffixOffset = this.getNextOffsetForwards(this.getSuffixSegments(), this.suffixOffset, this.suffixOffset);
            i++;
          }
        } else {
          let oldSuffixOffset = this.suffixOffset;
          do {
            checkTimeout();
            const newSuffixOffset = this.getSuffixSearchSpace().substring(this.suffixOffset + 1).search(internal.BOUNDARY_CHARS);
            if (newSuffixOffset === -1) {
              this.suffixOffset = this.getSuffixSearchSpace().length;
            } else {
              this.suffixOffset = this.suffixOffset + 1 + newSuffixOffset;
            }
                        if (this.getSuffixSearchSpace().substring(oldSuffixOffset, this.suffixOffset).search(internal.NON_BOUNDARY_CHARS) !== -1) {
              oldSuffixOffset = this.suffixOffset;
              i++;
            }
          } while (this.suffixOffset < this.getSuffixSearchSpace().length && i < desiredIterations);
        }
      }
    }
    this.numIterations++;

        return canExpandRange || canExpandContext;
  }

  /**
   ,* Sets up the factory for a range-based match with a highlight that crosses
   ,* block boundaries.
   ,*
   ,* Exactly one of this, setSharedSearchSpace, or setExactTextMatch should be
   ,* called so the factory can identify the fragment.
   ,*
   ,* @param {String} startSearchSpace - the maximum possible string which can be
   ,*     used to identify the start of the fragment
   ,* @param {String} endSearchSpace - the maximum possible string which can be
   ,*     used to identify the end of the fragment
   ,* @return {FragmentFactory} - returns |this| to allow call chaining and
   ,*     assignment
   ,*/
  setStartAndEndSearchSpace(startSearchSpace, endSearchSpace) {
    this.startSearchSpace = startSearchSpace;
    this.endSearchSpace = endSearchSpace;
    this.backwardsEndSearchSpace = reverseString(endSearchSpace);
    this.startOffset = 0;
    this.endOffset = endSearchSpace.length;
    this.mode = this.Mode.ALL_PARTS;
    return this;
  }

  /**
   ,* Sets up the factory for a range-based match with a highlight that doesn't
   ,* cross block boundaries.
   ,*
   ,* Exactly one of this, setStartAndEndSearchSpace, or setExactTextMatch should
   ,* be called so the factory can identify the fragment.
   ,*
   ,* @param {String} sharedSearchSpace - the full text of the highlight
   ,* @return {FragmentFactory} - returns |this| to allow call chaining and
   ,*     assignment
   ,*/
  setSharedSearchSpace(sharedSearchSpace) {
    this.sharedSearchSpace = sharedSearchSpace;
    this.backwardsSharedSearchSpace = reverseString(sharedSearchSpace);
    this.startOffset = 0;
    this.endOffset = sharedSearchSpace.length;
    this.mode = this.Mode.SHARED_START_AND_END;
    return this;
  }

  /**
   ,* Sets up the factory for an exact text match.
   ,*
   ,* Exactly one of this, setStartAndEndSearchSpace, or setSharedSearchSpace
   ,* should be called so the factory can identify the fragment.
   ,*
   ,* @param {String} exactTextMatch - the full text of the highlight
   ,* @return {FragmentFactory} - returns |this| to allow call chaining and
   ,*     assignment
   ,*/
  setExactTextMatch(exactTextMatch) {
    this.exactTextMatch = exactTextMatch;
    this.mode = this.Mode.CONTEXT_ONLY;
    return this;
  }

  /**
   ,* Sets up the factory for context-based matches.
   ,*
   ,* @param {String} prefixSearchSpace - the string to be used as the search
   ,*     space for prefix
   ,* @param {String} suffixSearchSpace - the string to be used as the search
   ,*     space for suffix
   ,* @return {FragmentFactory} - returns |this| to allow call chaining and
   ,*     assignment
   ,*/
  setPrefixAndSuffixSearchSpace(prefixSearchSpace, suffixSearchSpace) {
    if (prefixSearchSpace) {
      this.prefixSearchSpace = prefixSearchSpace;
      this.backwardsPrefixSearchSpace = reverseString(prefixSearchSpace);
      this.prefixOffset = prefixSearchSpace.length;
    }
    if (suffixSearchSpace) {
      this.suffixSearchSpace = suffixSearchSpace;
      this.suffixOffset = 0;
    }
    return this;
  }

  /**
   ,* Sets up the factory to use an instance of Intl.Segmenter when identifying
   ,* the start/end of words. |segmenter| is not actually retained; instead it is
   ,* used to create segment objects which are cached.
   ,*
   ,* This must be called AFTER any calls to setStartAndEndSearchSpace,
   ,* setSharedSearchSpace, and/or setPrefixAndSuffixSearchSpace, as these search
   ,* spaces will be segmented immediately.
   ,*
   ,* @param {Intl.Segmenter | Undefined} segmenter
   ,* @returns {FragmentFactory} - returns |this| to allow call chaining and
   ,*     assignment
   ,*/
  useSegmenter(segmenter) {
    if (segmenter == null) {
      return this;
    }
    if (this.mode === this.Mode.ALL_PARTS) {
      this.startSegments = segmenter.segment(this.startSearchSpace);
      this.endSegments = segmenter.segment(this.endSearchSpace);
    } else if (this.mode === this.Mode.SHARED_START_AND_END) {
      this.sharedSegments = segmenter.segment(this.sharedSearchSpace);
    }
    if (this.prefixSearchSpace) {
      this.prefixSegments = segmenter.segment(this.prefixSearchSpace);
    }
    if (this.suffixSearchSpace) {
      this.suffixSegments = segmenter.segment(this.suffixSearchSpace);
    }
    return this;
  }

  /**
   ,* @returns {number} - how many words should be added to the prefix and suffix
   ,*     when embiggening. This changes depending on the current state of the
   ,*     prefix/suffix, so it should be invoked once per embiggen, before either
   ,*     is modified.
   ,*/
  getNumberOfContextWordsToAdd() {
    return this.backwardsPrefixOffset() === 0 && this.suffixOffset === 0 ? WORDS_TO_ADD_FIRST_ITERATION : WORDS_TO_ADD_SUBSEQUENT_ITERATIONS;
  }

  /**
   ,* @returns {number} - how many words should be added to textStart and textEnd
   ,*     when embiggening. This changes depending on the current state of
   ,*     textStart/textEnd, so it should be invoked once per embiggen, before
   ,*     either is modified.
   ,*/
  getNumberOfRangeWordsToAdd() {
    return this.startOffset === 0 && this.backwardsEndOffset() === 0 ? WORDS_TO_ADD_FIRST_ITERATION : WORDS_TO_ADD_SUBSEQUENT_ITERATIONS;
  }

  /**
   ,* Helper method for embiggening using Intl.Segmenter. Finds the next offset
   ,* to be tried in the forwards direction (i.e., a prefix of the search space).
   ,* @param {Segments} segments - the output of segmenting the desired search
   ,*     space using Intl.Segmenter
   ,* @param {number} offset - the current offset
   ,* @param {string} searchSpace - the search space that was segmented
   ,* @returns {number} - the next offset which should be tried.
   ,*/
  getNextOffsetForwards(segments, offset, searchSpace) {
        let currentSegment = segments.containing(offset);
    while (currentSegment != null) {
      checkTimeout();
      const currentSegmentEnd = currentSegment.index + currentSegment.segment.length;
      if (currentSegment.isWordLike) {
        return currentSegmentEnd;
      }
      currentSegment = segments.containing(currentSegmentEnd);
    }
        
    return searchSpace.length;
  }

  /**
   ,* Helper method for embiggening using Intl.Segmenter. Finds the next offset
   ,* to be tried in the backwards direction (i.e., a suffix of the search
   ,* space).
   ,* @param {Segments} segments - the output of segmenting the desired search
   ,*     space using Intl.Segmenter
   ,* @param {number} offset - the current offset
   ,* @returns {number} - the next offset which should be tried.
   ,*/
  getNextOffsetBackwards(segments, offset) {
        let currentSegment = segments.containing(offset);

        
        
        
        if (!currentSegment || offset == currentSegment.index) {
            currentSegment = segments.containing(offset - 1);
    }
    while (currentSegment != null) {
      checkTimeout();
      if (currentSegment.isWordLike) {
        return currentSegment.index;
      }
      currentSegment = segments.containing(currentSegment.index - 1);
    }
        
    return 0;
  }

  /**
   ,* @return {String} - the string to be used as the search space for textStart
   ,*/
  getStartSearchSpace() {
    return this.mode === this.Mode.SHARED_START_AND_END ? this.sharedSearchSpace : this.startSearchSpace;
  }

  /**
   ,* @returns {Segments | Undefined} - the result of segmenting the start search
   ,*     space using Intl.Segmenter, or undefined if a segmenter was not
   ,*     provided.
   ,*/
  getStartSegments() {
    return this.mode === this.Mode.SHARED_START_AND_END ? this.sharedSegments : this.startSegments;
  }

  /**
   ,* @return {String} - the string to be used as the search space for textEnd
   ,*/
  getEndSearchSpace() {
    return this.mode === this.Mode.SHARED_START_AND_END ? this.sharedSearchSpace : this.endSearchSpace;
  }

  /**
   ,* @returns {Segments | Undefined} - the result of segmenting the end search
   ,*     space using Intl.Segmenter, or undefined if a segmenter was not
   ,*     provided.
   ,*/
  getEndSegments() {
    return this.mode === this.Mode.SHARED_START_AND_END ? this.sharedSegments : this.endSegments;
  }

  /**
   ,* @return {String} - the string to be used as the search space for textEnd,
   ,*     backwards.
   ,*/
  getBackwardsEndSearchSpace() {
    return this.mode === this.Mode.SHARED_START_AND_END ? this.backwardsSharedSearchSpace : this.backwardsEndSearchSpace;
  }

  /**
   ,* @return {String} - the string to be used as the search space for prefix
   ,*/
  getPrefixSearchSpace() {
    return this.prefixSearchSpace;
  }

  /**
   ,* @returns {Segments | Undefined} - the result of segmenting the prefix
   ,*     search space using Intl.Segmenter, or undefined if a segmenter was not
   ,*     provided.
   ,*/
  getPrefixSegments() {
    return this.prefixSegments;
  }

  /**
   ,* @return {String} - the string to be used as the search space for prefix,
   ,*     backwards.
   ,*/
  getBackwardsPrefixSearchSpace() {
    return this.backwardsPrefixSearchSpace;
  }

  /**
   ,* @return {String} - the string to be used as the search space for suffix
   ,*/
  getSuffixSearchSpace() {
    return this.suffixSearchSpace;
  }

  /**
   ,* @returns {Segments | Undefined} - the result of segmenting the suffix
   ,*     search space using Intl.Segmenter, or undefined if a segmenter was not
   ,*     provided.
   ,*/
  getSuffixSegments() {
    return this.suffixSegments;
  }

  /**
   ,* Helper method for doing arithmetic in the backwards search space.
   ,* @return {Number} - the current end offset, as a start offset in the
   ,*     backwards search space
   ,*/
  backwardsEndOffset() {
    return this.getEndSearchSpace().length - this.endOffset;
  }

  /**
   ,* Helper method for doing arithmetic in the backwards search space.
   ,* @param {Number} backwardsEndOffset - the desired new value of the start
   ,*     offset in the backwards search space
   ,*/
  setBackwardsEndOffset(backwardsEndOffset) {
    this.endOffset = this.getEndSearchSpace().length - backwardsEndOffset;
  }

  /**
   ,* Helper method for doing arithmetic in the backwards search space.
   ,* @return {Number} - the current prefix offset, as a start offset in the
   ,*     backwards search space
   ,*/
  backwardsPrefixOffset() {
    if (this.prefixOffset == null) return null;
    return this.getPrefixSearchSpace().length - this.prefixOffset;
  }

  /**
   ,* Helper method for doing arithmetic in the backwards search space.
   ,* @param {Number} backwardsPrefixOffset - the desired new value of the prefix
   ,*     offset in the backwards search space
   ,*/
  setBackwardsPrefixOffset(backwardsPrefixOffset) {
    if (this.prefixOffset == null) return;
    this.prefixOffset = this.getPrefixSearchSpace().length - backwardsPrefixOffset;
  }
};

/**
 ,* Helper class to calculate visible text from the start or end of a range
 ,* until a block boundary is reached or the range is exhausted.
 ,*/
const BlockTextAccumulator = class {
  /**
   ,* @param {Range} searchRange - the range for which the text in the last or
   ,*     first non empty block boundary will be calculated
   ,* @param {boolean} isForwardTraversal - true if nodes in
   ,*     searchRange will be forward traversed
   ,*/
  constructor(searchRange, isForwardTraversal) {
    this.searchRange = searchRange;
    this.isForwardTraversal = isForwardTraversal;
    this.textFound = false;
    this.textNodes = [];
    this.textInBlock = null;
  }
  /**
   ,* Adds the next node in the search space range traversal to the accumulator.
   ,* The accumulator then will keep track of the text nodes in the range until a
   ,* block boundary is found. Once a block boundary is found and the content of
   ,* the text nodes in the boundary is non empty, the property textInBlock will
   ,* be set with the content of the text nodes, trimmed of leading and trailing
   ,* whitespaces.
   ,* @param {Node} node - next node in the traversal of the searchRange
   ,*/
  appendNode(node) {
        
    if (this.textInBlock !== null) {
      return;
    }
        
    if (isBlock(node)) {
      if (this.textFound) {
                
        if (!this.isForwardTraversal) {
          this.textNodes.reverse();
        }
                
        this.textInBlock = this.textNodes.map(textNode => textNode.textContent).join('').trim();
      } else {
                
        this.textNodes = [];
      }
      return;
    }

        if (!isText(node)) return;

        
    const nodeToInsert = this.getNodeIntersectionWithRange(node);

        this.textFound = this.textFound || nodeToInsert.textContent.trim() !== '';
    this.textNodes.push(nodeToInsert);
  }

  /**
   ,* Calculates the intersection of a node with searchRange and returns a Text
   ,* Node with the intersection
   ,* @param {Node} node - the node to intercept with searchRange
   ,* @returns {Node} - node if node is fully within searchRange or a Text Node
   ,*     with the substring of the content of node inside the search range
   ,*/
  getNodeIntersectionWithRange(node) {
    let startOffset = null;
    let endOffset = null;
    if (node === this.searchRange.startContainer && this.searchRange.startOffset !== 0) {
      startOffset = this.searchRange.startOffset;
    }
    if (node === this.searchRange.endContainer && this.searchRange.endOffset !== node.textContent.length) {
      endOffset = this.searchRange.endOffset;
    }
    if (startOffset !== null || endOffset !== null) {
      return {
        textContent: node.textContent.substring(startOffset ?? 0, endOffset ?? node.textContent.length)
      };
    }
    return node;
  }
};

/**
 ,* @param {TextFragment} fragment - the candidate fragment
 ,* @return {boolean} - true iff the candidate fragment identifies exactly one
 ,*     portion of the document.
 ,*/
const isUniquelyIdentifying = fragment => {
  return processTextFragmentDirective(fragment).length === 1;
};

/**
 ,* Reverses a string. Compound unicode characters are preserved.
 ,* @param {String} string - the string to reverse
 ,* @return {String} - sdrawkcab |gnirts|
 ,*/
const reverseString = string => {
    
  return [...(string || '')].reverse().join('');
};

/**
 ,* Determines whether the conditions for an exact match are met.
 ,* @param {Range} range - the range for which a fragment is being generated.
 ,* @return {boolean} - true if exact matching (i.e., only
 ,*     textStart) can be used; false if range matching (i.e., both textStart and
 ,*     textEnd) must be used.
 ,*/
const canUseExactMatch = range => {
  if (range.toString().length > MAX_EXACT_MATCH_LENGTH) return false;
  return !containsBlockBoundary(range);
};

/**
 ,* Finds the node at which a forward traversal through |range| should begin,
 ,* based on the range's start container and offset values.
 ,* @param {Range} range - the range which will be traversed
 ,* @return {Node} - the node where traversal should begin
 ,*/
const getFirstNodeForBlockSearch = range => {
    
    let node = range.startContainer;
  if (node.nodeType == Node.ELEMENT_NODE && range.startOffset < node.childNodes.length) {
    node = node.childNodes[range.startOffset];
  }
  return node;
};

/**
 ,* Finds the node at which a backward traversal through |range| should begin,
 ,* based on the range's end container and offset values.
 ,* @param {Range} range - the range which will be traversed
 ,* @return {Node} - the node where traversal should begin
 ,*/
const getLastNodeForBlockSearch = range => {
    
    let node = range.endContainer;
  if (node.nodeType == Node.ELEMENT_NODE && range.endOffset > 0) {
    node = node.childNodes[range.endOffset - 1];
  }
  return node;
};

/**
 ,* Finds the first visible text node within a given range.
 ,* @param {Range} range - range in which to find the first visible text node
 ,* @returns {Node} - first visible text node within |range| or null if there are
 ,* no visible text nodes within |range|
 ,*/
const getFirstTextNode = range => {
    const firstNode = getFirstNodeForBlockSearch(range);
  if (isText(firstNode) && internal.isNodeVisible(firstNode)) {
    return firstNode;
  }

    
  const walker = internal.makeTextNodeWalker(range);
  walker.currentNode = firstNode;
  return walker.nextNode();
};

/**
 ,* Finds the last visible text node within a given range.
 ,* @param {Range} range - range in which to find the last visible text node
 ,* @returns {Node} - last visible text node within |range| or null if there are
 ,* no visible text nodes within |range|
 ,*/
const getLastTextNode = range => {
    const lastNode = getLastNodeForBlockSearch(range);
  if (isText(lastNode) && internal.isNodeVisible(lastNode)) {
    return lastNode;
  }

    
  const walker = internal.makeTextNodeWalker(range);
  walker.currentNode = lastNode;
  return internal.backwardTraverse(walker, new Set());
};

/**
 ,* Determines whether or not a range crosses a block boundary.
 ,* @param {Range} range - the range to investigate
 ,* @return {boolean} - true if a block boundary was found,
 ,*     false if no such boundary was found.
 ,*/
const containsBlockBoundary = range => {
  const tempRange = range.cloneRange();
  let node = getFirstNodeForBlockSearch(tempRange);
  const walker = makeWalkerForNode(node);
  if (!walker) {
    return false;
  }
  const finishedSubtrees = new Set();
  while (!tempRange.collapsed && node != null) {
    if (isBlock(node)) return true;
    if (node != null) tempRange.setStartAfter(node);
    node = internal.forwardTraverse(walker, finishedSubtrees);
    checkTimeout();
  }
  return false;
};

/**
 ,* Attempts to find a word start within the given text node, starting at
 ,* |offset| and working backwards.
 ,*
 ,* @param {Node} node - a node to be searched
 ,* @param {Number|Undefined} startOffset - the character offset within |node|
 ,*     where the selected text begins. If undefined, the entire node will be
 ,*     searched.
 ,* @return {Number} the number indicating the offset to which a range should
 ,*     be set to ensure it starts on a word bound. Returns -1 if the node is not
 ,*     a text node, or if no word boundary character could be found.
 ,*/
const findWordStartBoundInTextNode = (node, startOffset) => {
  if (node.nodeType !== Node.TEXT_NODE) return -1;
  const offset = startOffset != null ? startOffset : node.data.length;

    
  if (offset < node.data.length && internal.BOUNDARY_CHARS.test(node.data[offset])) return offset;
  const precedingText = node.data.substring(0, offset);
  const boundaryIndex = reverseString(precedingText).search(internal.BOUNDARY_CHARS);
  if (boundaryIndex !== -1) {
        
    return offset - boundaryIndex;
  }
  return -1;
};

/**
 ,* Attempts to find a word end within the given text node, starting at |offset|.
 ,*
 ,* @param {Node} node - a node to be searched
 ,* @param {Number|Undefined} endOffset - the character offset within |node|
 ,*     where the selected text end. If undefined, the entire node will be
 ,*     searched.
 ,* @return {Number} the number indicating the offset to which a range should
 ,*     be set to ensure it ends on a word bound. Returns -1 if the node is not
 ,*     a text node, or if no word boundary character could be found.
 ,*/
const findWordEndBoundInTextNode = (node, endOffset) => {
  if (node.nodeType !== Node.TEXT_NODE) return -1;
  const offset = endOffset != null ? endOffset : 0;

    
  if (offset < node.data.length && offset > 0 && internal.BOUNDARY_CHARS.test(node.data[offset - 1])) {
    return offset;
  }
  const followingText = node.data.substring(offset);
  const boundaryIndex = followingText.search(internal.BOUNDARY_CHARS);
  if (boundaryIndex !== -1) {
    return offset + boundaryIndex;
  }
  return -1;
};

/**
 ,* Helper method to create a TreeWalker useful for finding a block boundary near
 ,* a given node.
 ,* @param {Node} node - the node where the search should start
 ,* @param {Node|Undefined} endNode - optional; if included, the root of the
 ,*     walker will be chosen to ensure it can traverse at least as far as this
 ,*     node.
 ,* @return {TreeWalker} - a TreeWalker, rooted in a block ancestor of |node|,
 ,*     currently pointing to |node|, which will traverse only visible text and
 ,*     element nodes.
 ,*/
const makeWalkerForNode = (node, endNode) => {
  if (!node) {
    return undefined;
  }

    
  let blockAncestor = node;
  const endNodeNotNull = endNode != null ? endNode : node;
  while (!blockAncestor.contains(endNodeNotNull) || !isBlock(blockAncestor)) {
    if (blockAncestor.parentNode) {
      blockAncestor = blockAncestor.parentNode;
    }
  }
  const walker = document.createTreeWalker(blockAncestor, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, node => {
    return internal.acceptNodeIfVisibleInRange(node);
  });
  walker.currentNode = node;
  return walker;
};

/**
 ,* Modifies the start of the range, if necessary, to ensure the selection text
 ,* starts after a boundary char (whitespace, etc.) or a block boundary. Can only
 ,* expand the range, not shrink it.
 ,* @param {Range} range - the range to be modified
 ,*/
const expandRangeStartToWordBound = range => {
  const segmenter = internal.makeNewSegmenter();
  if (segmenter) {
        
    const startNode = getFirstNodeForBlockSearch(range);
    if (startNode !== range.startContainer) {
      range.setStartBefore(startNode);
    }
    expandToNearestWordBoundaryPointUsingSegments(segmenter, /* expandForward= */false, range);
  } else {
        
    const newOffset = findWordStartBoundInTextNode(range.startContainer, range.startOffset);
    if (newOffset !== -1) {
      range.setStart(range.startContainer, newOffset);
      return;
    }

        
    if (isBlock(range.startContainer) && range.startOffset === 0) {
      return;
    }
    const walker = makeWalkerForNode(range.startContainer);
    if (!walker) {
      return;
    }
    const finishedSubtrees = new Set();
    let node = internal.backwardTraverse(walker, finishedSubtrees);
    while (node != null) {
      const newOffset = findWordStartBoundInTextNode(node);
      if (newOffset !== -1) {
        range.setStart(node, newOffset);
        return;
      }

            
      if (isBlock(node)) {
        if (node.contains(range.startContainer)) {
                    
          range.setStart(node, 0);
        } else {
                    
          range.setStartAfter(node);
        }
        return;
      }
      node = internal.backwardTraverse(walker, finishedSubtrees);
            
            range.collapse();
    }
  }
};

/**
 ,* Moves the range edges to the first and last visible text nodes inside of it.
 ,* If there are no visible text nodes in the range then it is collapsed.
 ,* @param {Range} range - the range to be modified
 ,*/
const moveRangeEdgesToTextNodes = range => {
  const firstTextNode = getFirstTextNode(range);
    if (firstTextNode == null) {
    range.collapse();
    return;
  }
  const firstNode = getFirstNodeForBlockSearch(range);

    if (firstNode !== firstTextNode) {
    range.setStart(firstTextNode, 0);
  }
  const lastNode = getLastNodeForBlockSearch(range);
  const lastTextNode = getLastTextNode(range);
    

    if (lastNode !== lastTextNode) {
    range.setEnd(lastTextNode, lastTextNode.textContent.length);
  }
};

/**
 ,* Uses Intl.Segmenter to shift the start or end of a range to a word boundary.
 ,* Helper method for expandWord*ToWordBound methods.
 ,* @param {Intl.Segmenter} segmenter - object to use for word segmenting
 ,* @param {boolean} isRangeEnd - true if the range end should be modified, false
 ,*     if the range start should be modified
 ,* @param {Range} range - the range to modify
 ,*/
const expandToNearestWordBoundaryPointUsingSegments = (segmenter, isRangeEnd, range) => {
    
  const boundary = isRangeEnd ? {
    node: range.endContainer,
    offset: range.endOffset
  } : {
    node: range.startContainer,
    offset: range.startOffset
  };
  const nodes = getTextNodesInSameBlock(boundary.node);
  const preNodeText = nodes.preNodes.reduce((prev, cur) => {
    return prev.concat(cur.textContent);
  }, '');
  const innerNodeText = nodes.innerNodes.reduce((prev, cur) => {
    return prev.concat(cur.textContent);
  }, '');
  let offsetInText = preNodeText.length;
  if (boundary.node.nodeType === Node.TEXT_NODE) {
    offsetInText += boundary.offset;
  } else if (isRangeEnd) {
    offsetInText += innerNodeText.length;
  }

    const postNodeText = nodes.postNodes.reduce((prev, cur) => {
    return prev.concat(cur.textContent);
  }, '');
  const allNodes = [...nodes.preNodes, ...nodes.innerNodes, ...nodes.postNodes];

    
    if (allNodes.length == 0) {
    return;
  }
  const text = preNodeText.concat(innerNodeText, postNodeText);
  const segments = segmenter.segment(text);
  const foundSegment = segments.containing(offsetInText);
  if (!foundSegment) {
    if (isRangeEnd) {
      range.setEndAfter(allNodes[allNodes.length - 1]);
    } else {
      range.setEndBefore(allNodes[0]);
    }
    return;
  }

    
    if (!foundSegment.isWordLike) {
    return;
  }

    
  if (offsetInText === foundSegment.index || offsetInText === foundSegment.index + foundSegment.segment.length) {
    return;
  }

    
  const desiredOffsetInText = isRangeEnd ? foundSegment.index + foundSegment.segment.length : foundSegment.index;
  let newNodeIndexInText = 0;
  for (const node of allNodes) {
    if (newNodeIndexInText <= desiredOffsetInText && desiredOffsetInText < newNodeIndexInText + node.textContent.length) {
      const offsetInNode = desiredOffsetInText - newNodeIndexInText;
      if (isRangeEnd) {
        if (offsetInNode >= node.textContent.length) {
          range.setEndAfter(node);
        } else {
          range.setEnd(node, offsetInNode);
        }
      } else {
        if (offsetInNode >= node.textContent.length) {
          range.setStartAfter(node);
        } else {
          range.setStart(node, offsetInNode);
        }
      }
      return;
    }
    newNodeIndexInText += node.textContent.length;
  }

    
  if (isRangeEnd) {
    range.setEndAfter(allNodes[allNodes.length - 1]);
  } else {
    range.setStartBefore(allNodes[0]);
  }
};

/**
 ,* @typedef {Object} TextNodeLists - the result of traversing the DOM to
 ,*     extract TextNodes
 ,* @property {TextNode[]} preNodes - the nodes appearing before a specified
 ,*     starting node
 ,* @property {TextNode[]} innerNodes - a list containing |node| if it is a
 ,*     text node, or any text node children of |node|.
 ,* @property {TextNode[]} postNodes - the nodes appearing after a specified
 ,*     starting node
 ,*/

/**
 ,* Traverses the DOM to extract all TextNodes appearing in the same block level
 ,* as |node| (i.e., those that are descendents of a common ancestor of |node|
 ,* with no other block elements in between.)
 ,* @param {TextNode} node
 ,* @returns {TextNodeLists}
 ,*/
const getTextNodesInSameBlock = node => {
  const preNodes = [];
    const backWalker = makeWalkerForNode(node);
  if (!backWalker) {
    return;
  }
  const finishedSubtrees = new Set();
  let backNode = internal.backwardTraverse(backWalker, finishedSubtrees);
  while (backNode != null && !isBlock(backNode)) {
    checkTimeout();
    if (backNode.nodeType === Node.TEXT_NODE) {
      preNodes.push(backNode);
    }
    backNode = internal.backwardTraverse(backWalker, finishedSubtrees);
  }
  preNodes.reverse();
  const innerNodes = [];
  if (node.nodeType === Node.TEXT_NODE) {
    innerNodes.push(node);
  } else {
    const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, node => {
      return internal.acceptNodeIfVisibleInRange(node);
    });
    walker.currentNode = node;
    let child = walker.nextNode();
    while (child != null) {
      checkTimeout();
      if (child.nodeType === Node.TEXT_NODE) {
        innerNodes.push(child);
      }
      child = walker.nextNode();
    }
  }
  const postNodes = [];
  const forwardWalker = makeWalkerForNode(node);
  if (!forwardWalker) {
    return;
  }
    
  const finishedSubtreesForward = new Set([node]);
  let forwardNode = internal.forwardTraverse(forwardWalker, finishedSubtreesForward);
  while (forwardNode != null && !isBlock(forwardNode)) {
    checkTimeout();
    if (forwardNode.nodeType === Node.TEXT_NODE) {
      postNodes.push(forwardNode);
    }
    forwardNode = internal.forwardTraverse(forwardWalker, finishedSubtreesForward);
  }
  return {
    preNodes: preNodes,
    innerNodes: innerNodes,
    postNodes: postNodes
  };
};

/**
 ,* Modifies the end of the range, if necessary, to ensure the selection text
 ,* ends before a boundary char (whitespace, etc.) or a block boundary. Can only
 ,* expand the range, not shrink it.
 ,* @param {Range} range - the range to be modified
 ,*/
const expandRangeEndToWordBound = range => {
  const segmenter = internal.makeNewSegmenter();
  if (segmenter) {
        
    const endNode = getLastNodeForBlockSearch(range);
    if (endNode !== range.endContainer) {
      range.setEndAfter(endNode);
    }
    expandToNearestWordBoundaryPointUsingSegments(segmenter, /* expandForward= */true, range);
  } else {
    let initialOffset = range.endOffset;
    let node = range.endContainer;
    if (node.nodeType === Node.ELEMENT_NODE) {
      if (range.endOffset < node.childNodes.length) {
        node = node.childNodes[range.endOffset];
      }
    }
    const walker = makeWalkerForNode(node);
    if (!walker) {
      return;
    }
        
    const finishedSubtrees = new Set([node]);
    while (node != null) {
      checkTimeout();
      const newOffset = findWordEndBoundInTextNode(node, initialOffset);
            
      initialOffset = null;
      if (newOffset !== -1) {
        range.setEnd(node, newOffset);
        return;
      }

            
      if (isBlock(node)) {
        if (node.contains(range.endContainer)) {
                    
          range.setEnd(node, node.childNodes.length);
        } else {
                    
          range.setEndBefore(node);
        }
        return;
      }
      node = internal.forwardTraverse(walker, finishedSubtrees);
    }
        
        range.collapse();
  }
};

/**
 ,* Helper to determine if a node is a block element or not.
 ,* @param {Node} node - the node to evaluate
 ,* @return {Boolean} - true if the node is an element classified as block-level
 ,*/
const isBlock = node => {
  return node.nodeType === Node.ELEMENT_NODE && (internal.BLOCK_ELEMENTS.includes(node.tagName) || node.tagName === 'HTML' || node.tagName === 'BODY');
};

/**
 ,* Helper to determine if a node is a Text Node or not
 ,* @param {Node} node - the node to evaluate
 ,* @returns {Boolean} - true if the node is a Text Node
 ,*/
const isText = node => {
  return node.nodeType === Node.TEXT_NODE;
};
const forTesting = {
  containsBlockBoundary: containsBlockBoundary,
  doGenerateFragment: doGenerateFragment,
  expandRangeEndToWordBound: expandRangeEndToWordBound,
  expandRangeStartToWordBound: expandRangeStartToWordBound,
  findWordEndBoundInTextNode: findWordEndBoundInTextNode,
  findWordStartBoundInTextNode: findWordStartBoundInTextNode,
  FragmentFactory: FragmentFactory,
  getSearchSpaceForEnd: getSearchSpaceForEnd,
  getSearchSpaceForStart: getSearchSpaceForStart,
  getTextNodesInSameBlock: getTextNodesInSameBlock,
  recordStartTime: recordStartTime,
  BlockTextAccumulator: BlockTextAccumulator,
  getFirstTextNode: getFirstTextNode,
  getLastTextNode: getLastTextNode,
  moveRangeEdgesToTextNodes: moveRangeEdgesToTextNodes
};


exports.forTesting = forTesting;
if (typeof goog !== 'undefined') {
    goog.declareModuleId('googleChromeLabs.textFragmentPolyfill.fragmentGenerationUtils');
  }
#+end_src


**** someday maybe
=C-c l=, =C-c M-w=, =M-w=  are all similar commands in emacs.
Maybe, the most intuitive keybinding for /copy link to highlight/  is =C-c l= 

Copy multiple items to kill ring by talking to emacsclient and pushing to emacs kill ring.
#+begin_src js :noweb-ref "js/someday"
/*
  //better to move some functionality into C-c l
if (selected_text === undefined || selected_text.length === 0) {
  save_to_emacs_kill_ring(`${url}`);
  save_to_emacs_kill_ring(`[[${url}][${title}]]`);
} else {
  url = turn_url_into_link_to_selected_text_fragment(url);
  save_to_emacs_kill_ring(`${url}`);
  save_to_emacs_kill_ring(`#+begin_quote ${url}\n${process.env.QUTE_SELECTED_TEXT}\n#+end_quote`);
  save_to_emacs_kill_ring(selected_text);  
}*/
#+end_src

***** CANCELLED docs for link to selection
Microsoft edge abuses =#:~:text=
#+begin_quote Eg
https://en.wikipedia.org/wiki/Paul_Graham_(programmer)#:~:text=Graham%20considers%20a%20hypothetical%20Blub%20programmer.%20When%20the%20programmer%20looks%20down
#+end_quote

The syntax
[[https://supple.com.au/tools/scroll-to-text-fragment-generator-bookmarklet/#:~:text=watch][Scroll To Text Fragment Generator & Bookmarklet ¬ª Supple Digital the video.-,Scroll To Text Fragment]]

**** bugs
The gold standard for this functionality is the right click menu's =Copy link to highlight= in Google Chrome.
Currently, my implementation below has some bugs where it doesnt get the correct link sometimes.

Some problems may be due to ~browse-url-dwim-search~ silently and unintuitively editing the url given to it.
One example of failure:-
The link to the last paragraph on http://www.paulgraham.com/bio.html doesnt seems to work.

Sometimes, when the selected text contains weird quote characters, eg reddit, the copy fails with an error message of "Error bla bla"
Next time this happens, I will copy the exact error message.

Cannot run =C-: copy-link-to-selection= inside caret-selection-mode.
Because =C-:= isnt bound inside that mode.
*** qutebrowser userscript --> bash script --> emacsclient
This script copies the selected text and the url.
/url to selected text/ is still pretty brittle, hence, I have settled on using just the url.

Userscript is different from a Greasemonkey script. Userscripts can be written in any language.
I have written this one in bash, because:-
1. it makes it convenient to use emacaclient to communicate  with running emacs server.
2. its trivial to parse env variables in bash
---------------------------------------------------------------------------------------------------
   
Whenever an userscript is run, qutebrowser passes certain environment variables to it.
Among these, QUTE_SELECTED_TEXT, QUTE_TITLE, QUTE_URL are useful for me here.

Lets write the main entrypoint of our userscript. I had to create the directory =mkdir ~/.config/qutebrowser/userscripts/=
#+begin_src bash :tangle ~/.config/qutebrowser/userscripts/copy-selection-as-orgmode-quote.sh :comments no :tangle-mode o755
#!/usr/bin/bash
<<Escape the url>>
<<Escape the title>>
<<Escape the selection>>
emacsclient --eval "(qutebrowser-userscript/copy-as-quote \"$URL0\" \"$TITLE0\" \"$SELECTED_TEXT0\")"
#+end_src

There are only two characters that elip needs escaping: double quote, backslash. [[info:elisp#Syntax for Strings][source]]
#+begin_src bash :noweb-ref "Escape the selection"
SELECTED_TEXT0="$QUTE_SELECTED_TEXT"
SELECTED_TEXT0="${SELECTED_TEXT0//\\/\\\\}" # escape backslashes
SELECTED_TEXT0="${SELECTED_TEXT0//\"/\\\"}" # escape double quotes
#+end_src
llly,
#+begin_src bash :noweb-ref "Escape the url"
#someday maybe:-
#Disabled because I dont think its necessary
#url-encode the url
#QUTE_URL2=$(echo $QUTE_URL |python3 -c "import sys;from urllib.parse import quote;print(quote(sys.stdin.readline()))")

URL0="$QUTE_URL"
URL0="${URL0//\\/\\\\}" # escape backslashes
URL0="${URL0//\"/\\\"}" # escape double quotes
#+end_src
#+begin_src bash :noweb-ref "Escape the title"
TITLE0="$QUTE_TITLE"
TITLE0="${TITLE0//\\/\\\\}" # escape backslashes
TITLE0="${TITLE0//\"/\\\"}" # escape double quotes
#+end_src

*** Keybinding for the Userscript
#+begin_src python :noweb-ref "C-M-w should copy selection as orgmode quote"
'spawn --userscript copy-selection-as-orgmode-quote.sh'
#+end_src
*** someday maybe
=C-c l=, =C-c M-w=, =M-w=  are all similar commands in emacs.
Maybe, the most intuitive keybinding for /copy link to highlight/  is =C-c l= 

** Add copied text =M-w= to kill ring
*** qutebrowser userscript --> bash script --> emacsclient
This script copies the selected text to the emacs kill ring

Whenever an userscript is run, qutebrowser passes certain environment variables to it.
Among these, QUTE_SELECTED_TEXT is useful for me here.

Lets write the main entrypoint of our userscript. I had to create the directory =mkdir ~/.config/qutebrowser/userscripts/=
#+begin_src bash :tangle ~/.config/qutebrowser/userscripts/copy-selection-to-kill-ring.sh :comments no :tangle-mode o755
#!/usr/bin/bash

<<Escape the selection>>
emacsclient --eval "(kill-new \"$SELECTED_TEXT0\")"
#+end_src

There are only two characters that elisp needs escaping: double quote, backslash. [[info:elisp#Syntax for Strings][source]]
*** Keybinding for the Userscript
#+begin_src python :noweb-ref "M-w should copy selection to kill ring"
'spawn --userscript copy-selection-to-kill-ring.sh'
#+end_src
** Turn off dark mode
[[https://www.squarefree.com/bookmarklets/zap.html#zap_colors][source]]

Invoking a jseval from keypress can be accomplished as follows:-

I need to escape single and double quotes.

#+begin_src python :noweb-ref "qute/zap_colors2"
"""jseval (function zap_colors() {console.log(\'turning off dark mode\');  var newSS;  var styles=\'* { background: white ! important; color: black !important } :link, :link * { color: #0000EE !important } :visited, :visited * { color: #551A8B !important }\';  if(document.createStyleSheet) {    document.createStyleSheet(\"javascript:\'\"+styles+\"\'\");  } else {    newSS=document.createElement(\'link\');    newSS.rel=\'stylesheet\';    newSS.href=\'data:text/css,\'+escape(styles);    document.getElementsByTagName(\"head\")[0].appendChild(newSS);  }})();"""
#+end_src


** CANCELLED Someday, integrate Qutebrowser's command pallette into M-x
Say I want to call ~:download-clear~
I could instead call =M-x qute/download-clear=

ie, the elisp function ~qute/download-clear~ must be mapped to the qutebrowser command ~download-clear~.

Do such mapping for each of the qutebrowser commands.

Maybe the architecture could be:-

emacs -----(talks to)-----> qute's FIFO file  ------(talks to)--> qutebrowser

** WAITING Disable two finger trackpad zoom
Because I mostly accidentally trigger it, never found it useful over =C-+=
[[https://github.com/qutebrowser/qutebrowser/issues/7704][Ability to disable pinch zoom ¬∑ Issue #7704 ¬∑ qutebrowser/qutebrowser ¬∑ GitHub]]
After this issue is fixed, I will able to add this to my config.
** forward all unbound keys?
c.input.forward_unbound_keys = 'all'
c.input.match_counts = False
#config.bind('L', 'hint')
** how to select text using keyboard
Caret mode :- move the caret/cursor around
Caret Selection mode :- move the caret/cursor while selecting text on the way

From Normal mode, press =C-space= to enter Caret mode at beginning of webpage.

From =C-s= repeatedly until your interested word is selected,
now press =C-g= to exit search,
now pressing =C-space= enters Caret mode at that interesting word.

Use Caret mode to select around, emacs navigation keybindings work.

Once inside Caret mode, press =Space= to toggle between ~Caret Mode~ and ~Caret Selection Mode~

Note:- Press =xx= to interchange point and mark. This replicates the =C-x C-x= behaviour you are familiar from emacs buffers.

*** CANCELLED deprecated old method
# =C-s C-g C-g C-space C-f M-w=
# ie,
# You start out in /normal mode/
# C-s "some search term"
# C-g C-g ;; to get blue selection highlight
# C-space ;; to enter /insert mode/ from /normal mode/
# C-f     ;; to expand the selection
# M-w     ;; to copy

+someday maybe, learn how to bind C-space to "down-mouse-1"+
^easy: use caret mode
** how to open command palette
=C-;=  which works both in /normal mode/ & /insert mode/
** Scroll page such that 3 lines of previous page are visible
Those 3 lines will serve as context.
I am replicating this behaviour from the way scrolling pages works in emacs text buffers.
#+begin_src python :noweb-ref "Scroll up and down approx retaining 3 lines"
'<ctrl-v>': 'scroll-page 0 0.95',
'<alt-v>': 'scroll-page 0 -0.95',
#+end_src
** My keybindings for various modes
Copied from https://old.reddit.com/r/qutebrowser/comments/eh10i7/config_share_qute_with_emacs_keybindings/
#+begin_src python :noweb-ref "emacs-keybindings1"
c.tabs.background = True
# disable insert mode completely
c.input.insert_mode.auto_enter = False
c.input.insert_mode.auto_leave = False
c.input.insert_mode.plugins = False

# Forward unbound keys
c.input.forward_unbound_keys = "all"

ESC_BIND = 'clear-keychain ;; search ;; fullscreen --leave'

import string

c.bindings.default['normal'] = {}
c.bindings.default['insert'] = {}

# below block is actually useless, because I never utilise insert-mode
c.bindings.commands['insert'] = {
    '<ctrl-space>': 'mode-leave',
    #'<ctrl-g>': 'mode-leave;;fake-key <Left>;;fake-key <Right>',
    '<ctrl-g>': 'mode-leave',
    
    '<ctrl-f>': 'fake-key <Shift-Right>', 
    '<ctrl-b>': 'fake-key <Shift-Left>',
    '<ctrl-a>': 'scroll-to-perc --horizontal 0',
    '<ctrl-e>': 'scroll-to-perc --horizontal 100',
    '<ctrl-p>': 'fake-key <Shift-Up>',
    '<ctrl-n>': 'fake-key <Shift-Down>',
    #'<Return>': 'mode-leave',
    '<ctrl-w>': 'fake-key <Ctrl-x>;;message-info "cut to clipboard";;mode-leave',
    '<alt-w>': 'fake-key <Ctrl-c>;;message-info "copy to clipboard";;mode-leave',
    '<backspace>': 'fake-key <backspace>;;mode-leave',
    
    '<alt-x>': 'mode-leave;;cmd-set-text :',
    #'<ctrl-;>': 'mode-leave;;cmd-set-text :',
    
    '<alt-o>': 'mode-leave;;tab-focus last',
    #'<Tab>': 'fake-key <f1>'

    #expermients
    #'<ctrl-q>': 'mode-enter caret ;; selection-toggle',
}

for char in list(string.ascii_lowercase):
    c.bindings.commands['insert'].update({char: 'fake-key ' + char + ';;mode-leave'})

for CHAR in list(string.ascii_uppercase):
    c.bindings.commands['insert'].update({CHAR: 'fake-key ' + char + ';;mode-leave'})

for num in list(map(lambda x : str(x), range(0, 10))):
    c.bindings.commands['insert'].update({num: 'fake-key ' + num + ';;mode-leave'})

for symb in [',', '.', '/', '\'', ';', '[', ']', '\\',
             '!', '@','#','$','%','^','&','*','(',')','-','_', '=', '+', '`', '~',
             ':', '\"', '<', '>', '?','{', '}', '|']:
    c.bindings.commands['insert'].update({symb: 'insert-text ' + symb + ' ;;mode-leave'})


# Bindings
c.bindings.commands['normal'] = {
    '<F5>': 'reload',
    '<F12>': 'devtools bottom',
    # Navigation
    '<ctrl-]>': 'fake-key <Ctrl-Shift-Right>',
    '<ctrl-[>': 'fake-key <Ctrl-Shift-Left>',

    <<Scroll up and down approx retaining 3 lines>>

    '<ctrl-shift-v>': 'scroll-page 0 1',
    '<alt-shift-v>': 'scroll-page 0 -1',
    
    <<Scroll to top and bottom>>

    #'<alt-x>': 'cmd-set-text :',
    #'<ctrl-;>': 'cmd-set-text :',
    
    #'<ctrl-x>b': 'cmd-set-text -s :buffer;;fake-key <Down><Down><Down>',

    # searching
    '<ctrl-s>': 'cmd-set-text /',
    '<ctrl-r>': 'cmd-set-text ?',

    # hinting
    '<alt-i>': 'hint all',

    # hinting, but open selection in new tab
    '<ctrl-i>': 'hint links run :open --bg {hint-url}',
    #^some bug, --bg behaviour is the same as -t. I expected --bg to spawn tab in background.

    # editing
    '<alt-[>': 'back',
    '<alt-]>': 'forward',
    '<ctrl-/>': 'fake-key <Ctrl-z>',
    '<ctrl-shift-?>': 'fake-key <Ctrl-Shift-z>',
    '<ctrl-k>': 'fake-key <Shift-End>;;fake-key <Backspace>',
    '<ctrl-f>': 'fake-key <Right>',
    '<ctrl-b>': 'fake-key <Left>',

    #'<ctrl-x>h': 'fake-key <Ctrl-a>',
    '<ctrl-a>': 'scroll-to-perc --horizontal 0',
    '<ctrl-e>': 'scroll-to-perc --horizontal 100',
    
    '<ctrl-n>': 'fake-key <Down>',
    '<ctrl-p>': 'fake-key <Up>',
    '<alt-f>': 'fake-key <Ctrl-Right>',
    '<alt-b>': 'fake-key <Ctrl-Left>',
    '<ctrl-d>': 'fake-key <Delete>',
    '<alt-d>': 'fake-key <Ctrl-Delete>',
    '<alt-backspace>': 'fake-key <Ctrl-Backspace>',
    '<ctrl-w>': 'fake-key <Ctrl-x>;;message-info "cut to clipboard"',
    
    #'<alt-w>': 'fake-key <Ctrl-c>;;message-info "copied to clipboard"',
    '<alt-w>': <<M-w should copy selection to kill ring>>,
    
    #'<ctrl-y>': 'insert-text {primary}',
    '<ctrl-alt-w>': <<C-M-w should copy selection as orgmode quote>>,
    
    #This may be disabling number typing inside devtools
    '1': 'fake-key 1',
    '2': 'fake-key 2',
    '3': 'fake-key 3',
    '4': 'fake-key 4',
    '5': 'fake-key 5',
    '6': 'fake-key 6',
    '7': 'fake-key 7',
    '8': 'fake-key 8',
    '9': 'fake-key 9',
    '0': 'fake-key 0',

    # escape hatch
    #'<ctrl-h>': 'cmd-set-text -s :help',
    '<ctrl-g>': ESC_BIND,

    '<ctrl-space>': 'mode-enter caret',
    
    '<ctrl-+>': 'zoom-in',
    '<ctrl-=>': 'zoom-in',
    '<ctrl-->': 'zoom-out',

    <<qute/Select All>>
}

c.bindings.commands['command'] = {
    '<ctrl-s>': 'search-next',
    '<ctrl-r>': 'search-prev',

    '<ctrl-p>': 'completion-item-focus prev',
    '<ctrl-n>': 'completion-item-focus next',

    '<alt-p>': 'command-history-prev',
    '<alt-n>': 'command-history-next',

    # escape hatch
    '<ctrl-g>': 'mode-leave',
}

c.bindings.commands['hint'] = {
    # escape hatch
    '<ctrl-g>': 'mode-leave',
}


c.bindings.commands['caret'] = {
    '<ctrl-g>': 'mode-leave',
    
    #anoop:-
    #I love caret-mode
    #someday maybe, make this my default browsing mode
    #ie why should I browse the web in normal mode ever?

    #copy paste
    '<ctrl-w>': 'fake-key <Ctrl-x>;;message-info "cut to clipboard (in caret mode)"',
    #'<alt-w>': 'fake-key <Ctrl-c>;;message-info "copied to clipboard (in caret mode)";;selection-toggle',
    '<alt-w>': <<M-w should copy selection to kill ring>>,
    
    # enter mode
    '<Space>': 'selection-toggle',
    '<Ctrl-Space>': 'selection-toggle',
    #'<Ctrl-Space><Ctrl-Space>': 'selection-toggle', #keybinding doesnt work

    '<ctrl-b>': 'move-to-prev-char',
    '<ctrl-n>': 'move-to-next-line',
    '<ctrl-p>': 'move-to-prev-line',
    '<ctrl-f>': 'move-to-next-char',

    'H': 'scroll left',
    'L': 'scroll right',

    '<ctrl-e>': 'move-to-end-of-line',
    '<ctrl-a>': 'move-to-start-of-line',

    '<ctrl-v>': 'scroll down',
    '<alt-v>': 'scroll up',

    '<ctrl-alt-b>': 'move-to-start-of-prev-block',
    '<ctrl-alt-f>': 'move-to-start-of-next-block',

    '<alt-b>': 'move-to-prev-word',
    '<alt-f>': 'move-to-end-of-word',

    #'Q': 'mode-enter normal',
    #'V': 'selection-toggle --line',
    #'Y': 'yank selection -s',
    
    #'<ctrl-alt-a>': 'move-to-start-of-document', #keybinding not working
    #'<ctrl-alt-e>': 'move-to-end-of-document', #keybinding not working

    #currently exwm unable to send below key:- need to set simulation keys.
    #'<ctrl-x><ctrl-x>': 'selection-reverse',
    'xx': 'selection-reverse',

    #'<alt-f>': 'move-to-next-word',
    #'y': 'yank selection',
    '{': 'move-to-end-of-prev-block',
    '}': 'move-to-end-of-next-block',

    #'<Ctrl-Space>': 'selection-drop',
    #'<Escape>': 'mode-leave',
    #'<Return>': 'yank selection',

    # hinting
    '<alt-i>': 'hint all',

    # hinting, but open selection in new tab
    '<ctrl-i>': 'hint links run :open -t {hint-url}',

    '<ctrl-alt-w>': <<C-M-w should copy selection as orgmode quote>>,
}

#Is this how you do a global binding?:-
config.bind('<alt-r><alt-r>', 'config-source')
<<qute/Global keybindings>>
#I want to set M-w to copy, even when ?match-mode is active
#config.bind('<alt-w>', 'fake-key <Ctrl-c>;;message-info "copied to clipboard"')
#but, above seems to not be working

#open the command palette, in all modes
#todo: test if its working inside caret-selection-mode
config.bind('<ctrl-;>', 'cmd-set-text :')

#enable numbers
config.bind('1', 'fake-key 1')
config.bind('2', 'fake-key 2')
config.bind('3', 'fake-key 3')
config.bind('4', 'fake-key 4')
config.bind('5', 'fake-key 5')
config.bind('6', 'fake-key 6')
config.bind('7', 'fake-key 7')
config.bind('8', 'fake-key 8')
config.bind('9', 'fake-key 9')
config.bind('0', 'fake-key 0')
 
#c.url.searchengines["g"] = "https://www.google.com/search?q={}"
c.url.searchengines["g"] = "http://www.google.com/search?ie=utf-8&oe=utf-8&q={}"
c.url.searchengines["DEFAULT"] = "https://www.google.com/search?q={}"
#+end_src

** My zoom customisation
#+begin_src python :noweb-ref "Set default zoom level"
c.zoom.default = '150%'
#+end_src
** scroll to top/bottom

*** COMMENT binding =M-<= and =M->= directly in config.py
waiting for this [[https://github.com/qutebrowser/qutebrowser/issues/3736][bug]] to get resolved

scroll-to-perc 0 #scrolls to top
scroll-to-perc #without any arg, scrolls to bottom


#+begin_quote https://old.reddit.com/r/qutebrowser/comments/qx4ej4/having_trouble_with_an_emacslike_binding/
(assuming you are using a keyboard layout in which shift+, is <)

<Alt-Shift-,>

I've also tried Alt-<

What should be used is <Alt-Shift-<>: list of modifiers followed by the keysym. (You can test using the window that opens up when you run qutebrowser -T --debug :debug-keytester in a terminal.)

Sadly, it is currently impossible to bind a command to < (or >) with modifiers, and there are also other issues with using < and > in general in key chains; it is an open issue (GitHub #3736).

Even if you write the key chain as <Alt-Shift-Less> (Less and Greater are aliases for < and >), it will not work.
#+end_quote

Therefore, these dont work:-
#+begin_src python
#'<alt-shift-<>' : 'scroll-to-perc 0',
#'<alt-shift-,>': 'scroll-to-perc 0',
#'<alt-shift-.>': 'scroll-to-perc',
#+end_src

*** Binding to obscure keys
The trick is that [[file:~/.emacs.d/new.org::*M-< and M->][EXWM translates]] ~M-<~ and ~M->~ into =Ctrl+Shift+F1= and =Ctrl+Shift+F2= respectively.
#+begin_src python :noweb-ref "Scroll to top and bottom"
'<Ctrl-Shift-F1>' : 'scroll-to-perc 0',
'<Ctrl-Shift-F2>': 'scroll-to-perc',
#+end_src
Let me follow a convention:-
Henceforth, all such obscure keys which are called exclusively from emacs macros will be under =Ctrl+Shift+<Some function key>=
** select all
[[file:~/.emacs.d/new.org::*M-< and M->][EXWM translates]] ~C-x h~ into =Ctrl+Shift+F3=
source: [[https://old.reddit.com/r/qutebrowser/comments/17ilxkl/selecting_all_text_in_a_textarea/k704nzf/][The-Compiler comments on selecting all text in a textarea]]
#+begin_src python :noweb-ref "qute/Select All"
'<Ctrl-Shift-F3>' : 'fake-key <Ctrl-A>',
#+end_src

** how to click around using just keyboard
Press +C-l+ =M-i= to hint all clickable links
** how to open a new tab, with your search inputted
Just launch a new search using =C-c g=
** Why I have not hidden the status bar yet
I have incorporated all features of the statusbar into my emacs modeline itself.
Therefore, in a perfect world, I would have preferred to hide the status bar permanently.
#+begin_src python :noweb-ref "Status bar visibility - deprecated"
c.statusbar.show = 'never'
#+end_src

Whenever I invoke =C-s= with the statusbar hidden, I lose the scroll position.
This [[https://github.com/qutebrowser/qutebrowser/issues/6651][issue]] gave me a hint that this bug could be solved if I kept the statusbar enabled.
I gave it a try and seems like the problem doesnt happen if statusbar is visible.
Hence, I am being forced to keep the statusbar visible until this bug is fixed.
#+begin_src python :noweb-ref "Status bar visibility"
c.statusbar.show = 'always'
#+end_src
** Each paste must also add the item to the emacs kill ring
I need to talk to emacsclient in order to add items to its kill ring
I can talk to emacsclient using ~:spawn~

The relevant elisp function is ~(kill-new STRING &optional REPLACE)~

#+begin_src python :noweb-ref "qute/spawn/Add to Kill Ring"
spawn emacsclient --eval \'(kill-new \"{primary}\")\'
#+end_src
^Doubt: For now ~{primary}~ seems to be working for me. Should I have used ~{clipboard}~ instead?

Lets bind it
#+begin_src python :noweb-ref "qute/Global keybindings"
config.bind('<ctrl-y>', 'insert-text {primary};; <<qute/spawn/Add to Kill Ring>>')
#+end_src

** Set qutebrowser as the default web browser
[[file:~/.emacs.d/new.org::*Use qutebrowser for web browsing][Use qutebrowser for web browsing]]
** Dont re-open  tabs from previous desktop session
[[file:~/.emacs.d/new.org::*Quit Qutebrowser][Quit Qutebrowser]]
** WAITING Improve adblock
Qutebrowser adblock
To improve the adblock in qutebrowser, you need to install the Brave adblocker. This needs to be manually downloaded from pip (for now).

Run pip install adblock, followed by :adblock-update in qutebrowser.

** CANCELLED most comprehensive qutebrowser ricing, to study and steal
https://gitlab.com/Kaligule/qutebrowser-emacs-config/blob/master/config.py
[[https://qutebrowser.org/doc/help/commands.html][Read up about what each command does in docs]]
** COMMENT Workaround to fix Google not letting qutebrowser to login
This is no longer needed after updating qutebrowser
The default useragent of qutebrowser is ~Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) QtWebEngine/6.6.3 Chrome/112.0.5615.213 Safari/537.36~

I installed latest Firefox, and copied its useragent string to below:-
#+begin_src python :noweb-ref "Spoof user agent acceptable by google"
config.set('content.headers.user_agent',
           'Mozilla/5.0 (X11; Linux x86_64; rv:130.0) Gecko/20100101 Firefox/130.0',
           'accounts.google.com')

# https://www.whatismybrowser.com/detect/what-is-my-user-agent/
config.set('content.headers.user_agent',
           'Mozilla/5.0 (X11; Linux x86_64; rv:130.0) Gecko/20100101 Firefox/130.0',
           'www.whatismybrowser.com')
#+end_src
** Useragent spoof for chatgpt.com
Spoof as google chrome
#+begin_src python :noweb-ref "Spoof useragent acceptable by chatgpt"
config.set('content.headers.user_agent',
           'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
           'www.chatgpt.com')

config.set('content.headers.user_agent',
           'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
           'auth.openai.com')
#+end_src
** How to update qutebrowser
I have installed it inside a virtualenv inside ~/Documents folder.
The repos comes with a update script
#+begin_src bash
scripts/mkvenv.py --update
scripts/dev/update_3rdparty.py
#+end_src
** custom fonts
#+begin_src python :noweb-ref "My custom fonts"
c.fonts.prompts = '18pt monospace'
c.fonts.downloads = '18pt monospace'
c.fonts.statusbar = '18pt monospace'
c.fonts.contextmenu = '18pt monospace'
c.fonts.messages.info = '18pt monospace'
c.fonts.debug_console = '18pt monospace'
c.fonts.completion.entry = '18pt monospace'
c.fonts.completion.category = '18pt monospace'
#+end_src
** Dont immediately an focus older qutebrowser window when I run a new google search
^ie wait for google search to complete and then I manually activate that window

Stolen from:
#+begin_quote https://github.com/lrustand/qutebrowser.el?tab=readme-ov-file#required-qutebrowser-configurations
If you‚Äôre having trouble with existing Qutebrowser windows being raised and given focus when using one of the qutebrowser-launcher commands to open a new window, you might need to add the following line to your config.py:

# Avoid browser being focused when sending commands
c.new_instance_open_target = 'tab-silent'

Despite what the name of the setting might suggest, it does not seem to affect where new windows/tabs are opened, it only keeps from raising the last used window when sending commands using the commandline backend. It might not be necessary to set this option when using the IPC backend.
#+end_quote

Avoids browser being focused when sending commands. Dont activate qutebrowser window until google search is0 completed.
#+begin_src python :noweb-ref "Accept commands from C-c g silently"
c.new_instance_open_target = 'tab-silent'
#+end_src

** I want to avoid ever accidentally visiting the reddit homepage with addictive feed
Just redirect to r/emacs homepage if I visit the reddit homepage
I took the code from [[https://greasyfork.org/en/scripts/472364-near-block-explorer-url-rewriter/code][Near Block Explorer URL Rewriter - Source code]] and modified it to my needs.
#+begin_src js :tangle ~/.config/qutebrowser/greasemonkey/redditHomepageRedirect.user.js :comments no
// ==UserScript==
// @name         Avoid Reddit homepage
// @namespace    http://example.com/
// @version      1.0
// @description  Redirect https://old.reddit.com to https://old.reddit.com/r/clojure
// @author       Anoop
// @match        *://old.reddit.com/*
// @grant        none
// ==/UserScript==

(function() {
  //'use strict';

  ///console.log("Entered script ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ");
  
  function replaceURL() {
    // Get the current URL
    let currentURL = window.location.href;
    ///console.log("The current url is", currentURL);
    
    if (currentURL === "https://old.reddit.com/") {
      ///console.log("Redirecting from addictive reddit homepage feed to the peaceful clojure subreddit homepage");
      window.location.replace("https://old.reddit.com/r/Clojure/");
    }     
  }
  
  // Call the function to replace the URL
  replaceURL();
  
})();
#+end_src

** auto generated config.py, also this is the tangle target
The uncommented lines are manually inplace edits by me
#+begin_src python :tangle ~/.config/qutebrowser/config.py
## Autogenerated config.py
##
## NOTE: config.py is intended for advanced users who are comfortable
## with manually migrating the config file on qutebrowser upgrades. If
## you prefer, you can also configure qutebrowser using the
## :set/:bind/:config-* commands without having to write a config.py
## file.
##
## Documentation:
##   qute://help/configuring.html
##   qute://help/settings.html

## This is here so configs done via the GUI are still loaded.
## Remove it to not load settings done via the GUI.
# config.load_autoconfig(True)
<<No gui config>>

# No longer needed:-
# < <Spoof user agent acceptable by google> >
# No longer works:-
# < <Spoof useragent acceptable by chatgpt> >

## Aliases for commands. The keys of the given dictionary are the
## aliases, while the values are the commands they map to.
## Type: Dict
c.aliases = {
    'w': 'session-save',
    'q': 'close',
    'qa': 'quit',
    'wq': 'quit --save',
    'wqa': 'quit --save',
    'zap-colors': <<qute/zap_colors2>>,
    'light-color-theme': <<qute/zap_colors2>>,
    'translate': 'spawn --userscript translate',
}

## Time interval (in milliseconds) between auto-saves of
## config/cookies/etc.
## Type: Int
# c.auto_save.interval = 15000

## Always restore open sites when qutebrowser is reopened. Without this
## option set, `:wq` (`:quit --save`) needs to be used to save open tabs
## (and restore them), while quitting qutebrowser in any other way will
## not save/restore the session. By default, this will save to the
## session which was last loaded. This behavior can be customized via the
## `session.default_name` setting.
## Type: Bool
c.auto_save.session = False

## Backend to use to display websites. qutebrowser supports two different
## web rendering engines / backends, QtWebEngine and QtWebKit (not
## recommended). QtWebEngine is Qt's official successor to QtWebKit, and
## both the default/recommended backend. It's based on a stripped-down
## Chromium and regularly updated with security fixes and new features by
## the Qt project: https://wiki.qt.io/QtWebEngine QtWebKit was
## qutebrowser's original backend when the project was started. However,
## support for QtWebKit was discontinued by the Qt project with Qt 5.6 in
## 2016. The development of QtWebKit was picked up in an official fork:
## https://github.com/qtwebkit/qtwebkit - however, the project seems to
## have stalled again. The latest release (5.212.0 Alpha 4) from March
## 2020 is based on a WebKit version from 2016, with many known security
## vulnerabilities. Additionally, there is no process isolation and
## sandboxing. Due to all those issues, while support for QtWebKit is
## still available in qutebrowser for now, using it is strongly
## discouraged.
## Type: String
## Valid values:
##   - webengine: Use QtWebEngine (based on Chromium - recommended).
##   - webkit: Use QtWebKit (based on WebKit, similar to Safari - many known security issues!).
# c.backend = 'webengine'

## Map keys to other keys, so that they are equivalent in all modes. When
## the key used as dictionary-key is pressed, the binding for the key
## used as dictionary-value is invoked instead. This is useful for global
## remappings of keys, for example to map <Ctrl-[> to <Escape>. NOTE:
## This should only be used if two keys should always be equivalent, i.e.
## for things like <Enter> (keypad) and <Return> (non-keypad). For normal
## command bindings, qutebrowser works differently to vim: You always
## bind keys to commands, usually via `:bind` or `config.bind()`. Instead
## of using this setting, consider finding the command a key is bound to
## (e.g. via `:bind gg`) and then binding the same command to the desired
## key. Note that when a key is bound (via `bindings.default` or
## `bindings.commands`), the mapping is ignored.
## Type: Dict
# c.bindings.key_mappings = {'<Ctrl-[>': '<Escape>', '<Ctrl-6>': '<Ctrl-^>', '<Ctrl-M>': '<Return>', '<Ctrl-J>': '<Return>', '<Ctrl-I>': '<Tab>', '<Shift-Return>': '<Return>', '<Enter>': '<Return>', '<Shift-Enter>': '<Return>', '<Ctrl-Enter>': '<Ctrl-Return>'}

## When to show a changelog after qutebrowser was upgraded.
## Type: String
## Valid values:
##   - major: Show changelog for major upgrades (e.g. v2.0.0 -> v3.0.0).
##   - minor: Show changelog for major and minor upgrades (e.g. v2.0.0 -> v2.1.0).
##   - patch: Show changelog for major, minor and patch upgrades (e.g. v2.0.0 -> v2.0.1).
##   - never: Never show changelog after upgrades.
# c.changelog_after_upgrade = 'minor'

## Background color of the completion widget category headers.
## Type: QssColor
# c.colors.completion.category.bg = 'qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 #888888, stop:1 #505050)'

## Bottom border color of the completion widget category headers.
## Type: QssColor
# c.colors.completion.category.border.bottom = 'black'

## Top border color of the completion widget category headers.
## Type: QssColor
# c.colors.completion.category.border.top = 'black'

## Foreground color of completion widget category headers.
## Type: QtColor
# c.colors.completion.category.fg = 'white'

## Background color of the completion widget for even rows.
## Type: QssColor
# c.colors.completion.even.bg = '#333333'

## Text color of the completion widget. May be a single color to use for
## all columns or a list of three colors, one for each column.
## Type: List of QtColor, or QtColor
# c.colors.completion.fg = ['white', 'white', 'white']

## Background color of the selected completion item.
## Type: QssColor
# c.colors.completion.item.selected.bg = '#e8c000'

## Bottom border color of the selected completion item.
## Type: QssColor
# c.colors.completion.item.selected.border.bottom = '#bbbb00'

## Top border color of the selected completion item.
## Type: QssColor
# c.colors.completion.item.selected.border.top = '#bbbb00'

## Foreground color of the selected completion item.
## Type: QtColor
# c.colors.completion.item.selected.fg = 'black'

## Foreground color of the matched text in the selected completion item.
## Type: QtColor
# c.colors.completion.item.selected.match.fg = '#ff4444'

## Foreground color of the matched text in the completion.
## Type: QtColor
# c.colors.completion.match.fg = '#ff4444'

## Background color of the completion widget for odd rows.
## Type: QssColor
# c.colors.completion.odd.bg = '#444444'

## Color of the scrollbar in the completion view.
## Type: QssColor
# c.colors.completion.scrollbar.bg = '#333333'

## Color of the scrollbar handle in the completion view.
## Type: QssColor
# c.colors.completion.scrollbar.fg = 'white'

## Background color of disabled items in the context menu. If set to
## null, the Qt default is used.
## Type: QssColor
# c.colors.contextmenu.disabled.bg = None

## Foreground color of disabled items in the context menu. If set to
## null, the Qt default is used.
## Type: QssColor
# c.colors.contextmenu.disabled.fg = None

## Background color of the context menu. If set to null, the Qt default
## is used.
## Type: QssColor
# c.colors.contextmenu.menu.bg = None

## Foreground color of the context menu. If set to null, the Qt default
## is used.
## Type: QssColor
# c.colors.contextmenu.menu.fg = None

## Background color of the context menu's selected item. If set to null,
## the Qt default is used.
## Type: QssColor
# c.colors.contextmenu.selected.bg = None

## Foreground color of the context menu's selected item. If set to null,
## the Qt default is used.
## Type: QssColor
# c.colors.contextmenu.selected.fg = None

## Background color for the download bar.
## Type: QssColor
# c.colors.downloads.bar.bg = 'black'

## Background color for downloads with errors.
## Type: QtColor
# c.colors.downloads.error.bg = 'red'

## Foreground color for downloads with errors.
## Type: QtColor
# c.colors.downloads.error.fg = 'white'

## Color gradient start for download backgrounds.
## Type: QtColor
# c.colors.downloads.start.bg = '#0000aa'

## Color gradient start for download text.
## Type: QtColor
# c.colors.downloads.start.fg = 'white'

## Color gradient stop for download backgrounds.
## Type: QtColor
# c.colors.downloads.stop.bg = '#00aa00'

## Color gradient end for download text.
## Type: QtColor
# c.colors.downloads.stop.fg = 'white'

## Color gradient interpolation system for download backgrounds.
## Type: ColorSystem
## Valid values:
##   - rgb: Interpolate in the RGB color system.
##   - hsv: Interpolate in the HSV color system.
##   - hsl: Interpolate in the HSL color system.
##   - none: Don't show a gradient.
# c.colors.downloads.system.bg = 'rgb'

## Color gradient interpolation system for download text.
## Type: ColorSystem
## Valid values:
##   - rgb: Interpolate in the RGB color system.
##   - hsv: Interpolate in the HSV color system.
##   - hsl: Interpolate in the HSL color system.
##   - none: Don't show a gradient.
# c.colors.downloads.system.fg = 'rgb'

## Background color for hints. Note that you can use a `rgba(...)` value
## for transparency.
## Type: QssColor
# c.colors.hints.bg = 'qlineargradient(x1:0, y1:0, x2:0, y2:1, stop:0 rgba(255, 247, 133, 0.8), stop:1 rgba(255, 197, 66, 0.8))'

## Font color for hints.
## Type: QssColor
# c.colors.hints.fg = 'black'

## Font color for the matched part of hints.
## Type: QtColor
# c.colors.hints.match.fg = 'green'

## Background color of the keyhint widget.
## Type: QssColor
# c.colors.keyhint.bg = 'rgba(0, 0, 0, 80%)'

## Text color for the keyhint widget.
## Type: QssColor
# c.colors.keyhint.fg = '#FFFFFF'

## Highlight color for keys to complete the current keychain.
## Type: QssColor
# c.colors.keyhint.suffix.fg = '#FFFF00'

## Background color of an error message.
## Type: QssColor
# c.colors.messages.error.bg = 'red'

## Border color of an error message.
## Type: QssColor
# c.colors.messages.error.border = '#bb0000'

## Foreground color of an error message.
## Type: QssColor
# c.colors.messages.error.fg = 'white'

## Background color of an info message.
## Type: QssColor
# c.colors.messages.info.bg = 'black'

## Border color of an info message.
## Type: QssColor
# c.colors.messages.info.border = '#333333'

## Foreground color of an info message.
## Type: QssColor
# c.colors.messages.info.fg = 'white'

## Background color of a warning message.
## Type: QssColor
# c.colors.messages.warning.bg = 'darkorange'

## Border color of a warning message.
## Type: QssColor
# c.colors.messages.warning.border = '#d47300'

## Foreground color of a warning message.
## Type: QssColor
# c.colors.messages.warning.fg = 'black'

## Background color for prompts.
## Type: QssColor
# c.colors.prompts.bg = '#444444'

## Border used around UI elements in prompts.
## Type: String
# c.colors.prompts.border = '1px solid gray'

## Foreground color for prompts.
## Type: QssColor
# c.colors.prompts.fg = 'white'

## Background color for the selected item in filename prompts.
## Type: QssColor
# c.colors.prompts.selected.bg = 'grey'

## Foreground color for the selected item in filename prompts.
## Type: QssColor
# c.colors.prompts.selected.fg = 'white'

## Background color of the statusbar in caret mode.
## Type: QssColor
# c.colors.statusbar.caret.bg = 'purple'

## Foreground color of the statusbar in caret mode.
## Type: QssColor
# c.colors.statusbar.caret.fg = 'white'

## Background color of the statusbar in caret mode with a selection.
## Type: QssColor
# c.colors.statusbar.caret.selection.bg = '#a12dff'

## Foreground color of the statusbar in caret mode with a selection.
## Type: QssColor
# c.colors.statusbar.caret.selection.fg = 'white'

## Background color of the statusbar in command mode.
## Type: QssColor
# c.colors.statusbar.command.bg = 'black'

## Foreground color of the statusbar in command mode.
## Type: QssColor
# c.colors.statusbar.command.fg = 'white'

## Background color of the statusbar in private browsing + command mode.
## Type: QssColor
# c.colors.statusbar.command.private.bg = 'darkslategray'

## Foreground color of the statusbar in private browsing + command mode.
## Type: QssColor
# c.colors.statusbar.command.private.fg = 'white'

## Background color of the statusbar in insert mode.
## Type: QssColor
# c.colors.statusbar.insert.bg = 'darkgreen'

## Foreground color of the statusbar in insert mode.
## Type: QssColor
# c.colors.statusbar.insert.fg = 'white'

## Background color of the statusbar.
## Type: QssColor
# c.colors.statusbar.normal.bg = 'black'

## Foreground color of the statusbar.
## Type: QssColor
# c.colors.statusbar.normal.fg = 'white'

## Background color of the statusbar in passthrough mode.
## Type: QssColor
# c.colors.statusbar.passthrough.bg = 'darkblue'

## Foreground color of the statusbar in passthrough mode.
## Type: QssColor
# c.colors.statusbar.passthrough.fg = 'white'

## Background color of the statusbar in private browsing mode.
## Type: QssColor
# c.colors.statusbar.private.bg = '#666666'

## Foreground color of the statusbar in private browsing mode.
## Type: QssColor
# c.colors.statusbar.private.fg = 'white'

## Background color of the progress bar.
## Type: QssColor
# c.colors.statusbar.progress.bg = 'white'

## Foreground color of the URL in the statusbar on error.
## Type: QssColor
# c.colors.statusbar.url.error.fg = 'orange'

## Default foreground color of the URL in the statusbar.
## Type: QssColor
# c.colors.statusbar.url.fg = 'white'

## Foreground color of the URL in the statusbar for hovered links.
## Type: QssColor
# c.colors.statusbar.url.hover.fg = 'aqua'

## Foreground color of the URL in the statusbar on successful load
## (http).
## Type: QssColor
# c.colors.statusbar.url.success.http.fg = 'white'

## Foreground color of the URL in the statusbar on successful load
## (https).
## Type: QssColor
# c.colors.statusbar.url.success.https.fg = 'lime'

## Foreground color of the URL in the statusbar when there's a warning.
## Type: QssColor
# c.colors.statusbar.url.warn.fg = 'yellow'

## Background color of the tab bar.
## Type: QssColor
# c.colors.tabs.bar.bg = '#555555'

## Background color of unselected even tabs.
## Type: QtColor
# c.colors.tabs.even.bg = 'darkgrey'

## Foreground color of unselected even tabs.
## Type: QtColor
# c.colors.tabs.even.fg = 'white'

## Color for the tab indicator on errors.
## Type: QtColor
# c.colors.tabs.indicator.error = '#ff0000'

## Color gradient start for the tab indicator.
## Type: QtColor
# c.colors.tabs.indicator.start = '#0000aa'

## Color gradient end for the tab indicator.
## Type: QtColor
# c.colors.tabs.indicator.stop = '#00aa00'

## Color gradient interpolation system for the tab indicator.
## Type: ColorSystem
## Valid values:
##   - rgb: Interpolate in the RGB color system.
##   - hsv: Interpolate in the HSV color system.
##   - hsl: Interpolate in the HSL color system.
##   - none: Don't show a gradient.
# c.colors.tabs.indicator.system = 'rgb'

## Background color of unselected odd tabs.
## Type: QtColor
# c.colors.tabs.odd.bg = 'grey'

## Foreground color of unselected odd tabs.
## Type: QtColor
# c.colors.tabs.odd.fg = 'white'

## Background color of pinned unselected even tabs.
## Type: QtColor
# c.colors.tabs.pinned.even.bg = 'darkseagreen'

## Foreground color of pinned unselected even tabs.
## Type: QtColor
# c.colors.tabs.pinned.even.fg = 'white'

## Background color of pinned unselected odd tabs.
## Type: QtColor
# c.colors.tabs.pinned.odd.bg = 'seagreen'

## Foreground color of pinned unselected odd tabs.
## Type: QtColor
# c.colors.tabs.pinned.odd.fg = 'white'

## Background color of pinned selected even tabs.
## Type: QtColor
# c.colors.tabs.pinned.selected.even.bg = 'black'

## Foreground color of pinned selected even tabs.
## Type: QtColor
# c.colors.tabs.pinned.selected.even.fg = 'white'

## Background color of pinned selected odd tabs.
## Type: QtColor
# c.colors.tabs.pinned.selected.odd.bg = 'black'

## Foreground color of pinned selected odd tabs.
## Type: QtColor
# c.colors.tabs.pinned.selected.odd.fg = 'white'

## Background color of selected even tabs.
## Type: QtColor
# c.colors.tabs.selected.even.bg = 'black'

## Foreground color of selected even tabs.
## Type: QtColor
# c.colors.tabs.selected.even.fg = 'white'

## Background color of selected odd tabs.
## Type: QtColor
# c.colors.tabs.selected.odd.bg = 'black'

## Foreground color of selected odd tabs.
## Type: QtColor
# c.colors.tabs.selected.odd.fg = 'white'

## Background color of tooltips. If set to null, the Qt default is used.
## Type: QssColor
# c.colors.tooltip.bg = None

## Foreground color of tooltips. If set to null, the Qt default is used.
## Type: QssColor
# c.colors.tooltip.fg = None

## Background color for webpages if unset (or empty to use the theme's
## color).
## Type: QtColor
# c.colors.webpage.bg = 'white'

## Which algorithm to use for modifying how colors are rendered with
## darkmode. The `lightness-cielab` value was added with QtWebEngine 5.14
## and is treated like `lightness-hsl` with older QtWebEngine versions.
## Type: String
## Valid values:
##   - lightness-cielab: Modify colors by converting them to CIELAB color space and inverting the L value. Not available with Qt < 5.14.
##   - lightness-hsl: Modify colors by converting them to the HSL color space and inverting the lightness (i.e. the "L" in HSL).
##   - brightness-rgb: Modify colors by subtracting each of r, g, and b from their maximum value.
# c.colors.webpage.darkmode.algorithm = 'lightness-cielab'

## Contrast for dark mode. This only has an effect when
## `colors.webpage.darkmode.algorithm` is set to `lightness-hsl` or
## `brightness-rgb`.
## Type: Float
# c.colors.webpage.darkmode.contrast = 0.0

## Render all web contents using a dark theme. Example configurations
## from Chromium's `chrome://flags`:  - "With simple HSL/CIELAB/RGB-based
## inversion": Set   `colors.webpage.darkmode.algorithm` accordingly.  -
## "With selective image inversion": Set
## `colors.webpage.darkmode.policy.images` to `smart`.  - "With selective
## inversion of non-image elements": Set
## `colors.webpage.darkmode.threshold.text` to 150 and
## `colors.webpage.darkmode.threshold.background` to 205.  - "With
## selective inversion of everything": Combines the two variants   above.
## - "With increased text contrast": Set
## `colors.webpage.darkmode.increase_text_contrast` (QtWebEngine 6.3+)
## Type: Bool
# c.colors.webpage.darkmode.enabled = False

## Render all colors as grayscale. This only has an effect when
## `colors.webpage.darkmode.algorithm` is set to `lightness-hsl` or
## `brightness-rgb`.
## Type: Bool
# c.colors.webpage.darkmode.grayscale.all = False

## Desaturation factor for images in dark mode. If set to 0, images are
## left as-is. If set to 1, images are completely grayscale. Values
## between 0 and 1 desaturate the colors accordingly.
## Type: Float
# c.colors.webpage.darkmode.grayscale.images = 0.0

## Increase text contrast by drawing an outline of the uninverted color.
## Type: Bool
# c.colors.webpage.darkmode.increase_text_contrast = False

## Which images to apply dark mode to. With QtWebEngine 5.15.0, this
## setting can cause frequent renderer process crashes due to a
## https://codereview.qt-project.org/c/qt/qtwebengine-
## chromium/+/304211[bug in Qt].
## Type: String
## Valid values:
##   - always: Apply dark mode filter to all images.
##   - never: Never apply dark mode filter to any images.
##   - smart: Apply dark mode based on image content. Not available with Qt 5.15.0.
# c.colors.webpage.darkmode.policy.images = 'smart'

## Which pages to apply dark mode to. The underlying Chromium setting has
## been removed in QtWebEngine 5.15.3, thus this setting is ignored
## there. Instead, every element is now classified individually.
## Type: String
## Valid values:
##   - always: Apply dark mode filter to all frames, regardless of content.
##   - smart: Apply dark mode filter to frames based on background color.
# c.colors.webpage.darkmode.policy.page = 'smart'

## Threshold for inverting background elements with dark mode. Background
## elements with brightness above this threshold will be inverted, and
## below it will be left as in the original, non-dark-mode page. Set to
## 256 to never invert the color or to 0 to always invert it. Note: This
## behavior is the opposite of `colors.webpage.darkmode.threshold.text`!
## Type: Int
# c.colors.webpage.darkmode.threshold.background = 0

## Threshold for inverting text with dark mode. Text colors with
## brightness below this threshold will be inverted, and above it will be
## left as in the original, non-dark-mode page. Set to 256 to always
## invert text color or to 0 to never invert text color.
## Type: Int
# c.colors.webpage.darkmode.threshold.text = 256

## Value to use for `prefers-color-scheme:` for websites. The "light"
## value is only available with QtWebEngine 5.15.2+. On older versions,
## it is the same as "auto". The "auto" value is broken on QtWebEngine
## 5.15.2 due to a Qt bug. There, it will fall back to "light"
## unconditionally.
## Type: String
## Valid values:
##   - auto: Use the system-wide color scheme setting.
##   - light: Force a light theme.
##   - dark: Force a dark theme.
# c.colors.webpage.preferred_color_scheme = 'auto'

## Number of commands to save in the command history. 0: no history / -1:
## unlimited
## Type: Int
# c.completion.cmd_history_max_items = 100

## Delay (in milliseconds) before updating completions after typing a
## character.
## Type: Int
# c.completion.delay = 0

## Default filesystem autocomplete suggestions for :open. The elements of
## this list show up in the completion window under the Filesystem
## category when the command line contains `:open` but no argument.
## Type: List of String
# c.completion.favorite_paths = []

## Height (in pixels or as percentage of the window) of the completion.
## Type: PercOrInt
# c.completion.height = '50%'

## Minimum amount of characters needed to update completions.
## Type: Int
# c.completion.min_chars = 1

## Which categories to show (in which order) in the :open completion.
## Type: FlagList
## Valid values:
##   - searchengines
##   - quickmarks
##   - bookmarks
##   - history
##   - filesystem
# c.completion.open_categories = ['searchengines', 'quickmarks', 'bookmarks', 'history', 'filesystem']

## Move on to the next part when there's only one possible completion
## left.
## Type: Bool
# c.completion.quick = True

## Padding (in pixels) of the scrollbar handle in the completion window.
## Type: Int
# c.completion.scrollbar.padding = 2

## Width (in pixels) of the scrollbar in the completion window.
## Type: Int
# c.completion.scrollbar.width = 12

## When to show the autocompletion window.
## Type: String
## Valid values:
##   - always: Whenever a completion is available.
##   - auto: Whenever a completion is requested.
##   - never: Never.
# c.completion.show = 'always'

## Shrink the completion to be smaller than the configured size if there
## are no scrollbars.
## Type: Bool
# c.completion.shrink = False

## Format of timestamps (e.g. for the history completion). See
## https://sqlite.org/lang_datefunc.html and
## https://docs.python.org/3/library/datetime.html#strftime-strptime-
## behavior for allowed substitutions, qutebrowser uses both sqlite and
## Python to format its timestamps.
## Type: String
# c.completion.timestamp_format = '%Y-%m-%d %H:%M'

## Execute the best-matching command on a partial match.
## Type: Bool
# c.completion.use_best_match = False

## A list of patterns which should not be shown in the history. This only
## affects the completion. Matching URLs are still saved in the history
## (and visible on the `:history` page), but hidden in the completion.
## Changing this setting will cause the completion history to be
## regenerated on the next start, which will take a short while.
## Type: List of UrlPattern
# c.completion.web_history.exclude = []

## Number of URLs to show in the web history. 0: no history / -1:
## unlimited
## Type: Int
# c.completion.web_history.max_items = -1

## Require a confirmation before quitting the application.
## Type: ConfirmQuit
## Valid values:
##   - always: Always show a confirmation.
##   - multiple-tabs: Show a confirmation if multiple tabs are opened.
##   - downloads: Show a confirmation if downloads are running
##   - never: Never show a confirmation.
# c.confirm_quit = ['never']

## Automatically start playing `<video>` elements.
## Type: Bool
# c.content.autoplay = True

## List of URLs to ABP-style adblocking rulesets.  Only used when Brave's
## ABP-style adblocker is used (see `content.blocking.method`).  You can
## find an overview of available lists here:
## https://adblockplus.org/en/subscriptions - note that the special
## `subscribe.adblockplus.org` links aren't handled by qutebrowser, you
## will instead need to find the link to the raw `.txt` file (e.g. by
## extracting it from the `location` parameter of the subscribe URL and
## URL-decoding it).
## Type: List of Url
# c.content.blocking.adblock.lists = ['https://easylist.to/easylist/easylist.txt', 'https://easylist.to/easylist/easyprivacy.txt']

## Enable the ad/host blocker
## Type: Bool
# c.content.blocking.enabled = True

## Block subdomains of blocked hosts. Note: If only a single subdomain is
## blocked but should be allowed, consider using
## `content.blocking.whitelist` instead.
## Type: Bool
# c.content.blocking.hosts.block_subdomains = True

## List of URLs to host blocklists for the host blocker.  Only used when
## the simple host-blocker is used (see `content.blocking.method`).  The
## file can be in one of the following formats:  - An `/etc/hosts`-like
## file - One host per line - A zip-file of any of the above, with either
## only one file, or a file   named `hosts` (with any extension).  It's
## also possible to add a local file or directory via a `file://` URL. In
## case of a directory, all files in the directory are read as adblock
## lists.  The file `~/.config/qutebrowser/blocked-hosts` is always read
## if it exists.
## Type: List of Url
# c.content.blocking.hosts.lists = ['https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts']

## Which method of blocking ads should be used.  Support for Adblock Plus
## (ABP) syntax blocklists using Brave's Rust library requires the
## `adblock` Python package to be installed, which is an optional
## dependency of qutebrowser. It is required when either `adblock` or
## `both` are selected.
## Type: String
## Valid values:
##   - auto: Use Brave's ABP-style adblocker if available, host blocking otherwise
##   - adblock: Use Brave's ABP-style adblocker
##   - hosts: Use hosts blocking
##   - both: Use both hosts blocking and Brave's ABP-style adblocker
# c.content.blocking.method = 'auto'

## A list of patterns that should always be loaded, despite being blocked
## by the ad-/host-blocker. Local domains are always exempt from
## adblocking. Note this whitelists otherwise blocked requests, not
## first-party URLs. As an example, if `example.org` loads an ad from
## `ads.example.org`, the whitelist entry could be
## `https://ads.example.org/*`. If you want to disable the adblocker on a
## given page, use the `content.blocking.enabled` setting with a URL
## pattern instead.
## Type: List of UrlPattern
# c.content.blocking.whitelist = []

## Enable support for the HTML 5 web application cache feature. An
## application cache acts like an HTTP cache in some sense. For documents
## that use the application cache via JavaScript, the loader engine will
## first ask the application cache for the contents, before hitting the
## network.
## Type: Bool
# c.content.cache.appcache = True

## Maximum number of pages to hold in the global memory page cache. The
## page cache allows for a nicer user experience when navigating forth or
## back to pages in the forward/back history, by pausing and resuming up
## to _n_ pages. For more information about the feature, please refer to:
## https://webkit.org/blog/427/webkit-page-cache-i-the-basics/
## Type: Int
# c.content.cache.maximum_pages = 0

## Size (in bytes) of the HTTP network cache. Null to use the default
## value. With QtWebEngine, the maximum supported value is 2147483647 (~2
## GB).
## Type: Int
# c.content.cache.size = None

## Allow websites to read canvas elements. Note this is needed for some
## websites to work properly.
## Type: Bool
# c.content.canvas_reading = True

## Which cookies to accept. With QtWebEngine, this setting also controls
## other features with tracking capabilities similar to those of cookies;
## including IndexedDB, DOM storage, filesystem API, service workers, and
## AppCache. Note that with QtWebKit, only `all` and `never` are
## supported as per-domain values. Setting `no-3rdparty` or `no-
## unknown-3rdparty` per-domain on QtWebKit will have the same effect as
## `all`. If this setting is used with URL patterns, the pattern gets
## applied to the origin/first party URL of the page making the request,
## not the request URL. With QtWebEngine 5.15.0+, paths will be stripped
## from URLs, so URL patterns using paths will not match. With
## QtWebEngine 5.15.2+, subdomains are additionally stripped as well, so
## you will typically need to set this setting for `example.com` when the
## cookie is set on `somesubdomain.example.com` for it to work properly.
## To debug issues with this setting, start qutebrowser with `--debug
## --logfilter network --debug-flag log-cookies` which will show all
## cookies being set.
## Type: String
## Valid values:
##   - all: Accept all cookies.
##   - no-3rdparty: Accept cookies from the same origin only. This is known to break some sites, such as GMail.
##   - no-unknown-3rdparty: Accept cookies from the same origin only, unless a cookie is already set for the domain. On QtWebEngine, this is the same as no-3rdparty.
##   - never: Don't accept cookies at all.
# c.content.cookies.accept = 'all'

## Store cookies.
## Type: Bool
# c.content.cookies.store = True

## Default encoding to use for websites. The encoding must be a string
## describing an encoding such as _utf-8_, _iso-8859-1_, etc.
## Type: String
# c.content.default_encoding = 'iso-8859-1'
c.content.default_encoding = 'utf-8'

## Allow websites to share screen content.
## Type: BoolAsk
## Valid values:
##   - true
##   - false
##   - ask
# c.content.desktop_capture = 'ask'

## Try to pre-fetch DNS entries to speed up browsing.
## Type: Bool
# c.content.dns_prefetch = True

## Expand each subframe to its contents. This will flatten all the frames
## to become one scrollable page.
## Type: Bool
# c.content.frame_flattening = False

## Set fullscreen notification overlay timeout in milliseconds. If set to
## 0, no overlay will be displayed.
## Type: Int
# c.content.fullscreen.overlay_timeout = 3000

## Limit fullscreen to the browser window (does not expand to fill the
## screen).
## Type: Bool
# c.content.fullscreen.window = False

## Allow websites to request geolocations.
## Type: BoolAsk
## Valid values:
##   - true
##   - false
##   - ask
# c.content.geolocation = 'ask'

## Value to send in the `Accept-Language` header. Note that the value
## read from JavaScript is always the global value.
## Type: String
# c.content.headers.accept_language = 'en-US,en;q=0.9'

## Custom headers for qutebrowser HTTP requests.
## Type: Dict
# c.content.headers.custom = {}

## Value to send in the `DNT` header. When this is set to true,
## qutebrowser asks websites to not track your identity. If set to null,
## the DNT header is not sent at all.
## Type: Bool
# c.content.headers.do_not_track = True

## When to send the Referer header. The Referer header tells websites
## from which website you were coming from when visiting them. Note that
## with QtWebEngine, websites can override this preference by setting the
## `Referrer-Policy:` header, so that any websites visited from them get
## the full referer. No restart is needed with QtWebKit.
## Type: String
## Valid values:
##   - always: Always send the Referer. With QtWebEngine 6.2+, this value is unavailable and will act like `same-domain`.
##   - never: Never send the Referer. This is not recommended, as some sites may break.
##   - same-domain: Only send the Referer for the same domain. This will still protect your privacy, but shouldn't break any sites. With QtWebEngine, the referer will still be sent for other domains, but with stripped path information.
# c.content.headers.referer = 'same-domain'

## User agent to send.  The following placeholders are defined:  *
## `{os_info}`: Something like "X11; Linux x86_64". * `{webkit_version}`:
## The underlying WebKit version (set to a fixed value   with
## QtWebEngine). * `{qt_key}`: "Qt" for QtWebKit, "QtWebEngine" for
## QtWebEngine. * `{qt_version}`: The underlying Qt version. *
## `{upstream_browser_key}`: "Version" for QtWebKit, "Chrome" for
## QtWebEngine. * `{upstream_browser_version}`: The corresponding
## Safari/Chrome version. * `{qutebrowser_version}`: The currently
## running qutebrowser version.  The default value is equal to the
## unchanged user agent of QtWebKit/QtWebEngine.  Note that the value
## read from JavaScript is always the global value. With QtWebEngine
## between 5.12 and 5.14 (inclusive), changing the value exposed to
## JavaScript requires a restart.
## Type: FormatString
# c.content.headers.user_agent = 'Mozilla/5.0 ({os_info}) AppleWebKit/{webkit_version} (KHTML, like Gecko) {qt_key}/{qt_version} {upstream_browser_key}/{upstream_browser_version} Safari/{webkit_version}'

## Enable hyperlink auditing (`<a ping>`).
## Type: Bool
# c.content.hyperlink_auditing = False

## Load images automatically in web pages.
## Type: Bool
# c.content.images = True

## Show javascript alerts.
## Type: Bool
c.content.javascript.alert = False

## Allow JavaScript to close tabs.
## Type: Bool
# c.content.javascript.can_close_tabs = False

## Allow JavaScript to open new tabs without user interaction.
## Type: Bool
# c.content.javascript.can_open_tabs_automatically = False

## Allow JavaScript to read from or write to the clipboard. With
## QtWebEngine, writing the clipboard as response to a user interaction
## is always allowed.
## Type: String
## Valid values:
##   - none: Disable access to clipboard.
##   - access: Allow reading from and writing to the clipboard.
##   - access-paste: Allow accessing the clipboard and pasting clipboard content.
c.content.javascript.clipboard = 'access-paste'

## Enable JavaScript.
## Type: Bool
# c.content.javascript.enabled = True

## Log levels to use for JavaScript console logging messages. When a
## JavaScript message with the level given in the dictionary key is
## logged, the corresponding dictionary value selects the qutebrowser
## logger to use. On QtWebKit, the "unknown" setting is always used. The
## following levels are valid: `none`, `debug`, `info`, `warning`,
## `error`.
## Type: Dict
# c.content.javascript.log = {'unknown': 'debug', 'info': 'debug', 'warning': 'debug', 'error': 'debug'}

## Javascript messages to *not* show in the UI, despite a corresponding
## `content.javascript.log_message.levels` setting. Both keys and values
## are glob patterns, with the key matching the location of the error,
## and the value matching the error message. By default, the
## https://web.dev/csp/[Content security policy] violations triggered by
## qutebrowser's stylesheet handling are excluded, as those errors are to
## be expected and can't be easily handled by the underlying code.
## Type: Dict
# c.content.javascript.log_message.excludes = {'userscript:_qute_stylesheet': ['*Refused to apply inline style because it violates the following Content Security Policy directive: *']}

## Javascript message sources/levels to show in the qutebrowser UI. When
## a JavaScript message is logged from a location matching the glob
## pattern given in the key, and is from one of the levels listed as
## value, it's surfaced as a message in the qutebrowser UI. By default,
## errors happening in qutebrowser internally are shown to the user.
## Type: Dict
# c.content.javascript.log_message.levels = {'qute:*': ['error'], 'userscript:GM-*': [], 'userscript:*': ['error']}

## Use the standard JavaScript modal dialog for `alert()` and
## `confirm()`.
## Type: Bool
# c.content.javascript.modal_dialog = False

## Show javascript prompts.
## Type: Bool
# c.content.javascript.prompt = True

## Allow locally loaded documents to access other local URLs.
## Type: Bool
# c.content.local_content_can_access_file_urls = True

## Allow locally loaded documents to access remote URLs.
## Type: Bool
# c.content.local_content_can_access_remote_urls = False

## Enable support for HTML 5 local storage and Web SQL.
## Type: Bool
# c.content.local_storage = True

## Allow websites to record audio.
## Type: BoolAsk
## Valid values:
##   - true
##   - false
##   - ask
# c.content.media.audio_capture = 'ask'

## Allow websites to record audio and video.
## Type: BoolAsk
## Valid values:
##   - true
##   - false
##   - ask
# c.content.media.audio_video_capture = 'ask'

## Allow websites to record video.
## Type: BoolAsk
## Valid values:
##   - true
##   - false
##   - ask
# c.content.media.video_capture = 'ask'

## Allow websites to lock your mouse pointer.
## Type: BoolAsk
## Valid values:
##   - true
##   - false
##   - ask
# c.content.mouse_lock = 'ask'

## Automatically mute tabs. Note that if the `:tab-mute` command is used,
## the mute status for the affected tab is now controlled manually, and
## this setting doesn't have any effect.
## Type: Bool
# c.content.mute = False

## Netrc-file for HTTP authentication. If unset, `~/.netrc` is used.
## Type: File
# c.content.netrc_file = None

## Allow websites to show notifications.
## Type: BoolAsk
## Valid values:
##   - true
##   - false
##   - ask
c.content.notifications.enabled = False

## What notification presenter to use for web notifications. Note that
## not all implementations support all features of notifications: - The
## `qt` and `systray` options only support showing one notification at
## the time   and ignore the `tag` option to replace existing
## notifications. - The `herbe` option only supports showing one
## notification at the time and doesn't   show icons. - The `messages`
## option doesn't show icons and doesn't support the `click` and
## `close` events.
## Type: String
## Valid values:
##   - auto: Tries `libnotify`, `systray` and `messages`, uses the first one available without showing error messages.
##   - qt: Use Qt's native notification presenter, based on a system tray icon. Switching from or to this value requires a restart of qutebrowser.
##   - libnotify: Shows messages via DBus in a libnotify-compatible way. If DBus isn't available, falls back to `systray` or `messages`, but shows an error message.
##   - systray: Use a notification presenter based on a systray icon. Falls back to `libnotify` or `messages` if not systray is available. This is a reimplementation of the `qt` setting value, but with the possibility to switch to it at runtime.
##   - messages: Show notifications as qutebrowser messages. Most notification features aren't available.
##   - herbe: (experimental!) Show notifications using herbe (github.com/dudik/herbe). Most notification features aren't available.
# c.content.notifications.presenter = 'auto'

## Whether to show the origin URL for notifications. Note that URL
## patterns with this setting only get matched against the origin part of
## the URL, so e.g. paths in patterns will never match. Note that with
## the `qt` presenter, origins are never shown.
## Type: Bool
# c.content.notifications.show_origin = True

## Display PDF files via PDF.js in the browser without showing a download
## prompt. Note that the files can still be downloaded by clicking the
## download button in the pdf.js viewer. With this set to `false`, the
## `:prompt-open-download --pdfjs` command (bound to `<Ctrl-p>` by
## default) can be used in the download prompt.
## Type: Bool
# c.content.pdfjs = False
c.content.pdfjs = True

## Allow websites to request persistent storage quota via
## `navigator.webkitPersistentStorage.requestQuota`.
## Type: BoolAsk
## Valid values:
##   - true
##   - false
##   - ask
# c.content.persistent_storage = 'ask'

## Enable plugins in Web pages.
## Type: Bool
# c.content.plugins = False

## Request websites to minimize non-essentials animations and motion.
## This results in the `prefers-reduced-motion` CSS media query to
## evaluate to `reduce` (rather than `no-preference`). On Windows, if
## this setting is set to False, the system-wide animation setting is
## considered.
## Type: Bool
# c.content.prefers_reduced_motion = False

## Draw the background color and images also when the page is printed.
## Type: Bool
# c.content.print_element_backgrounds = True

## Open new windows in private browsing mode which does not record
## visited pages.
## Type: Bool
# c.content.private_browsing = False

## Proxy to use. In addition to the listed values, you can use a
## `socks://...` or `http://...` URL. Note that with QtWebEngine, it will
## take a couple of seconds until the change is applied, if this value is
## changed at runtime. Authentication for SOCKS proxies isn't supported
## due to Chromium limitations.
## Type: Proxy
## Valid values:
##   - system: Use the system wide proxy.
##   - none: Don't use any proxy
# c.content.proxy = 'system'

## Send DNS requests over the configured proxy.
## Type: Bool
# c.content.proxy_dns_requests = True

## Allow websites to register protocol handlers via
## `navigator.registerProtocolHandler`.
## Type: BoolAsk
## Valid values:
##   - true
##   - false
##   - ask
# c.content.register_protocol_handler = 'ask'

## Enable quirks (such as faked user agent headers) needed to get
## specific sites to work properly.
## Type: Bool
# c.content.site_specific_quirks.enabled = True

## Disable a list of named quirks.
## Type: FlagList
## Valid values:
##   - ua-whatsapp
##   - ua-google
##   - ua-slack
##   - ua-googledocs
##   - js-whatsapp-web
##   - js-discord
##   - js-string-replaceall
##   - js-array-at
##   - misc-krunker
##   - misc-mathml-darkmode
# c.content.site_specific_quirks.skip = []

## How to proceed on TLS certificate errors.
## Type: String
## Valid values:
##   - ask: Ask how to proceed for every certificate error (unless non-overridable due to HSTS).
##   - ask-block-thirdparty: Ask how to proceed for normal page loads, but silently block resource loads.
##   - block: Automatically block loading on certificate errors.
##   - load-insecurely: Force loading pages despite certificate errors. This is *insecure* and should be avoided. Instead of using this, consider fixing the underlying issue or importing a self-signed certificate via `certutil` (or Chromium) instead.
# c.content.tls.certificate_errors = 'ask'

## How navigation requests to URLs with unknown schemes are handled.
## Type: String
## Valid values:
##   - disallow: Disallows all navigation requests to URLs with unknown schemes.
##   - allow-from-user-interaction: Allows navigation requests to URLs with unknown schemes that are issued from user-interaction (like a mouse-click), whereas other navigation requests (for example from JavaScript) are suppressed.
##   - allow-all: Allows all navigation requests to URLs with unknown schemes.
# c.content.unknown_url_scheme_policy = 'allow-from-user-interaction'

## List of user stylesheet filenames to use.
## Type: List of File, or File
# c.content.user_stylesheets = []

## Enable WebGL.
## Type: Bool
# c.content.webgl = True

## Which interfaces to expose via WebRTC.
## Type: String
## Valid values:
##   - all-interfaces: WebRTC has the right to enumerate all interfaces and bind them to discover public interfaces.
##   - default-public-and-private-interfaces: WebRTC should only use the default route used by http. This also exposes the associated default private address. Default route is the route chosen by the OS on a multi-homed endpoint.
##   - default-public-interface-only: WebRTC should only use the default route used by http. This doesn't expose any local addresses.
##   - disable-non-proxied-udp: WebRTC should only use TCP to contact peers or servers unless the proxy server supports UDP. This doesn't expose any local addresses either.
# c.content.webrtc_ip_handling_policy = 'all-interfaces'

## Monitor load requests for cross-site scripting attempts. Suspicious
## scripts will be blocked and reported in the devtools JavaScript
## console. Note that bypasses for the XSS auditor are widely known and
## it can be abused for cross-site info leaks in some scenarios, see:
## https://www.chromium.org/developers/design-documents/xss-auditor
## Type: Bool
# c.content.xss_auditing = False

## Directory to save downloads to. If unset, a sensible OS-specific
## default is used.
## Type: Directory
# c.downloads.location.directory = None

## Prompt the user for the download location. If set to false,
## `downloads.location.directory` will be used.
## Type: Bool
# c.downloads.location.prompt = True

## Remember the last used download directory.
## Type: Bool
# c.downloads.location.remember = True

## What to display in the download filename input.
## Type: String
## Valid values:
##   - path: Show only the download path.
##   - filename: Show only download filename.
##   - both: Show download path and filename.
# c.downloads.location.suggestion = 'path'

## Default program used to open downloads. If null, the default internal
## handler is used. Any `{}` in the string will be expanded to the
## filename, else the filename will be appended.
## Type: String
# c.downloads.open_dispatcher = None

## Where to show the downloaded files.
## Type: VerticalPosition
## Valid values:
##   - top
##   - bottom
# c.downloads.position = 'top'

## Automatically abort insecure (HTTP) downloads originating from secure
## (HTTPS) pages. For per-domain settings, the relevant URL is the URL
## initiating the download, not the URL the download itself is coming
## from. It's not recommended to set this setting to false globally.
## Type: Bool
# c.downloads.prevent_mixed_content = True

## Duration (in milliseconds) to wait before removing finished downloads.
## If set to -1, downloads are never removed.
## Type: Int
# c.downloads.remove_finished = -1

## Editor (and arguments) to use for the `edit-*` commands. The following
## placeholders are defined:  * `{file}`: Filename of the file to be
## edited. * `{line}`: Line in which the caret is found in the text. *
## `{column}`: Column in which the caret is found in the text. *
## `{line0}`: Same as `{line}`, but starting from index 0. * `{column0}`:
## Same as `{column}`, but starting from index 0.
## Type: ShellCommand
# c.editor.command = ['gvim', '-f', '{file}', '-c', 'normal {line}G{column0}l']
# Copied from [[https://config.daviwil.com/desktop][Desktop Environment - config.daviwil.com]]
# Edit fields in Emacs with Ctrl+E
c.editor.command = ["emacsclient", "+{line}:{column}", "{file}"]

## Encoding to use for the editor.
## Type: Encoding
# c.editor.encoding = 'utf-8'

## Delete the temporary file upon closing the editor.
## Type: Bool
# c.editor.remove_file = True

## Command (and arguments) to use for selecting a single folder in forms.
## The command should write the selected folder path to the specified
## file or stdout. The following placeholders are defined: * `{}`:
## Filename of the file to be written to. If not contained in any
## argument, the   standard output of the command is read instead.
## Type: ShellCommand
# c.fileselect.folder.command = ['xterm', '-e', 'ranger', '--choosedir={}']

## Handler for selecting file(s) in forms. If `external`, then the
## commands specified by `fileselect.single_file.command`,
## `fileselect.multiple_files.command` and `fileselect.folder.command`
## are used to select one file, multiple files, and folders,
## respectively.
## Type: String
## Valid values:
##   - default: Use the default file selector.
##   - external: Use an external command.
# c.fileselect.handler = 'default'

## Command (and arguments) to use for selecting multiple files in forms.
## The command should write the selected file paths to the specified file
## or to stdout, separated by newlines. The following placeholders are
## defined: * `{}`: Filename of the file to be written to. If not
## contained in any argument, the   standard output of the command is
## read instead.
## Type: ShellCommand
# c.fileselect.multiple_files.command = ['xterm', '-e', 'ranger', '--choosefiles={}']

## Command (and arguments) to use for selecting a single file in forms.
## The command should write the selected file path to the specified file
## or stdout. The following placeholders are defined: * `{}`: Filename of
## the file to be written to. If not contained in any argument, the
## standard output of the command is read instead.
## Type: ShellCommand
# c.fileselect.single_file.command = ['xterm', '-e', 'ranger', '--choosefile={}']

## Font used in the completion categories.
## Type: Font
# c.fonts.completion.category = 'bold default_size default_family'

## Font used in the completion widget.
## Type: Font
# c.fonts.completion.entry = 'default_size default_family'

## Font used for the context menu. If set to null, the Qt default is
## used.
## Type: Font
# c.fonts.contextmenu = None
c.fonts.contextmenu = "20pt monospace"

## Font used for the debugging console.
## Type: Font
# c.fonts.debug_console = 'default_size default_family'

## Default font families to use. Whenever "default_family" is used in a
## font setting, it's replaced with the fonts listed here. If set to an
## empty value, a system-specific monospace default is used.
## Type: List of Font, or Font
# c.fonts.default_family = []

## Default font size to use. Whenever "default_size" is used in a font
## setting, it's replaced with the size listed here. Valid values are
## either a float value with a "pt" suffix, or an integer value with a
## "px" suffix.
## Type: String
# c.fonts.default_size = '10pt'

## Font used for the downloadbar.
## Type: Font
# c.fonts.downloads = 'default_size default_family'

## Font used for the hints.
## Type: Font
# c.fonts.hints = 'bold default_size default_family'
c.fonts.hints = "17pt monospace"

## Font used in the keyhint widget.
## Type: Font
# c.fonts.keyhint = 'default_size default_family'

## Font used for error messages.
## Type: Font
# c.fonts.messages.error = 'default_size default_family'

## Font used for info messages.
## Type: Font
# c.fonts.messages.info = 'default_size default_family'

## Font used for warning messages.
## Type: Font
# c.fonts.messages.warning = 'default_size default_family'

## Font used for prompts.
## Type: Font
# c.fonts.prompts = 'default_size sans-serif'

## Font used in the statusbar.
## Type: Font
# c.fonts.statusbar = 'default_size default_family'

## Font used for selected tabs.
## Type: Font
# c.fonts.tabs.selected = 'default_size default_family'

## Font used for unselected tabs.
## Type: Font
# c.fonts.tabs.unselected = 'default_size default_family'

## Font used for tooltips. If set to null, the Qt default is used.
## Type: Font
# c.fonts.tooltip = None

## Font family for cursive fonts.
## Type: FontFamily
# c.fonts.web.family.cursive = ''

## Font family for fantasy fonts.
## Type: FontFamily
# c.fonts.web.family.fantasy = ''

## Font family for fixed fonts.
## Type: FontFamily
# c.fonts.web.family.fixed = ''

## Font family for sans-serif fonts.
## Type: FontFamily
# c.fonts.web.family.sans_serif = ''

## Font family for serif fonts.
## Type: FontFamily
# c.fonts.web.family.serif = ''

## Font family for standard fonts.
## Type: FontFamily
# c.fonts.web.family.standard = ''

## Default font size (in pixels) for regular text.
## Type: Int
# c.fonts.web.size.default = 16

## Default font size (in pixels) for fixed-pitch text.
## Type: Int
# c.fonts.web.size.default_fixed = 13

## Hard minimum font size (in pixels).
## Type: Int
# c.fonts.web.size.minimum = 0

## Minimum logical font size (in pixels) that is applied when zooming
## out.
## Type: Int
# c.fonts.web.size.minimum_logical = 6

## When a hint can be automatically followed without pressing Enter.
## Type: String
## Valid values:
##   - always: Auto-follow whenever there is only a single hint on a page.
##   - unique-match: Auto-follow whenever there is a unique non-empty match in either the hint string (word mode) or filter (number mode).
##   - full-match: Follow the hint when the user typed the whole hint (letter, word or number mode) or the element's text (only in number mode).
##   - never: The user will always need to press Enter to follow a hint.
# c.hints.auto_follow = 'unique-match'

## Duration (in milliseconds) to ignore normal-mode key bindings after a
## successful auto-follow.
## Type: Int
# c.hints.auto_follow_timeout = 0

## CSS border value for hints.
## Type: String
# c.hints.border = '1px solid #E3BE23'

## Characters used for hint strings.
## Type: UniqueCharString
# c.hints.chars = 'asdfghjkl'

## Dictionary file to be used by the word hints.
## Type: File
# c.hints.dictionary = '/usr/share/dict/words'

## Which implementation to use to find elements to hint.
## Type: String
## Valid values:
##   - javascript: Better but slower
##   - python: Slightly worse but faster
# c.hints.find_implementation = 'python'

## Hide unmatched hints in rapid mode.
## Type: Bool
# c.hints.hide_unmatched_rapid_hints = True

## Leave hint mode when starting a new page load.
## Type: Bool
# c.hints.leave_on_load = False

## Minimum number of characters used for hint strings.
## Type: Int
# c.hints.min_chars = 1

## Mode to use for hints.
## Type: String
## Valid values:
##   - number: Use numeric hints. (In this mode you can also type letters from the hinted element to filter and reduce the number of elements that are hinted.)
##   - letter: Use the characters in the `hints.chars` setting.
##   - word: Use hints words based on the html elements and the extra words.
# c.hints.mode = 'letter'

## Comma-separated list of regular expressions to use for 'next' links.
## Type: List of Regex
# c.hints.next_regexes = ['\\bnext\\b', '\\bmore\\b', '\\bnewer\\b', '\\b[>‚Üí‚â´]\\b', '\\b(>>|¬ª)\\b', '\\bcontinue\\b']

## Padding (in pixels) for hints.
## Type: Padding
# c.hints.padding = {'top': 0, 'bottom': 0, 'left': 3, 'right': 3}

## Comma-separated list of regular expressions to use for 'prev' links.
## Type: List of Regex
# c.hints.prev_regexes = ['\\bprev(ious)?\\b', '\\bback\\b', '\\bolder\\b', '\\b[<‚Üê‚â™]\\b', '\\b(<<|¬´)\\b']

## Rounding radius (in pixels) for the edges of hints.
## Type: Int
# c.hints.radius = 3

## Scatter hint key chains (like Vimium) or not (like dwb). Ignored for
## number hints.
## Type: Bool
# c.hints.scatter = True

## CSS selectors used to determine which elements on a page should have
## hints.
## Type: Dict
# c.hints.selectors = {'all': ['a', 'area', 'textarea', 'select', 'input:not([type="hidden"])', 'button', 'frame', 'iframe', 'img', 'link', 'summary', '[contenteditable]:not([contenteditable="false"])', '[onclick]', '[onmousedown]', '[role="link"]', '[role="option"]', '[role="button"]', '[role="tab"]', '[role="checkbox"]', '[role="menuitem"]', '[role="menuitemcheckbox"]', '[role="menuitemradio"]', '[role="treeitem"]', '[aria-haspopup]', '[ng-click]', '[ngClick]', '[data-ng-click]', '[x-ng-click]', '[tabindex]:not([tabindex="-1"])'], 'links': ['a[href]', 'area[href]', 'link[href]', '[role="link"][href]'], 'images': ['img'], 'media': ['audio', 'img', 'video'], 'url': ['[src]', '[href]'], 'inputs': ['input[type="text"]', 'input[type="date"]', 'input[type="datetime-local"]', 'input[type="email"]', 'input[type="month"]', 'input[type="number"]', 'input[type="password"]', 'input[type="search"]', 'input[type="tel"]', 'input[type="time"]', 'input[type="url"]', 'input[type="week"]', 'input:not([type])', '[contenteditable]:not([contenteditable="false"])', 'textarea']}

## Make characters in hint strings uppercase.
## Type: Bool
# c.hints.uppercase = False

## Maximum time (in minutes) between two history items for them to be
## considered being from the same browsing session. Items with less time
## between them are grouped when being displayed in `:history`. Use -1 to
## disable separation.
## Type: Int
# c.history_gap_interval = 30

## Allow Escape to quit the crash reporter.
## Type: Bool
# c.input.escape_quits_reporter = True

## Which unbound keys to forward to the webview in normal mode.
## Type: String
## Valid values:
##   - all: Forward all unbound keys.
##   - auto: Forward unbound non-alphanumeric keys.
##   - none: Don't forward any keys.
# c.input.forward_unbound_keys = 'auto'

## Enter insert mode if an editable element is clicked.
## Type: Bool
# c.input.insert_mode.auto_enter = True

## Leave insert mode if a non-editable element is clicked.
## Type: Bool
# c.input.insert_mode.auto_leave = True

## Automatically enter insert mode if an editable element is focused
## after loading the page.
## Type: Bool
# c.input.insert_mode.auto_load = False

## Leave insert mode when starting a new page load. Patterns may be
## unreliable on this setting, and they may match the url you are
## navigating to, or the URL you are navigating from.
## Type: Bool
# c.input.insert_mode.leave_on_load = True

## Switch to insert mode when clicking flash and other plugins.
## Type: Bool
# c.input.insert_mode.plugins = False

## Include hyperlinks in the keyboard focus chain when tabbing.
## Type: Bool
# c.input.links_included_in_focus_chain = True

## Interpret number prefixes as counts for bindings. This enables for vi-
## like bindings that can be prefixed with a number to indicate a count.
## Disabling it allows for emacs-like bindings where number keys are
## passed through (according to `input.forward_unbound_keys`) instead.
## Type: Bool
# c.input.match_counts = True

## Whether the underlying Chromium should handle media keys. On Linux,
## disabling this also disables Chromium's MPRIS integration.
## Type: Bool
# c.input.media_keys = True

## Mode to change to when focusing on a tab/URL changes.
## Type: String
## Valid values:
##   - normal
##   - insert
##   - passthrough
# c.input.mode_override = None

## Enable back and forward buttons on the mouse.
## Type: Bool
# c.input.mouse.back_forward_buttons = True

## Enable Opera-like mouse rocker gestures. This disables the context
## menu.
## Type: Bool
# c.input.mouse.rocker_gestures = False

## Timeout (in milliseconds) for partially typed key bindings. If the
## current input forms only partial matches, the keystring will be
## cleared after this time. If set to 0, partially typed bindings are
## never cleared.
## Type: Int
# c.input.partial_timeout = 0

## Enable spatial navigation. Spatial navigation consists in the ability
## to navigate between focusable elements, such as hyperlinks and form
## controls, on a web page by using the Left, Right, Up and Down arrow
## keys. For example, if a user presses the Right key, heuristics
## determine whether there is an element they might be trying to reach
## towards the right and which element they probably want.
## Type: Bool
# c.input.spatial_navigation = False

## Keychains that shouldn't be shown in the keyhint dialog. Globs are
## supported, so `;*` will blacklist all keychains starting with `;`. Use
## `*` to disable keyhints.
## Type: List of String
# c.keyhint.blacklist = []

## Time (in milliseconds) from pressing a key to seeing the keyhint
## dialog.
## Type: Int
# c.keyhint.delay = 500

## Rounding radius (in pixels) for the edges of the keyhint dialog.
## Type: Int
# c.keyhint.radius = 6

## Level for console (stdout/stderr) logs. Ignored if the `--loglevel` or
## `--debug` CLI flags are used.
## Type: LogLevel
## Valid values:
##   - vdebug
##   - debug
##   - info
##   - warning
##   - error
##   - critical
# c.logging.level.console = 'info'

## Level for in-memory logs.
## Type: LogLevel
## Valid values:
##   - vdebug
##   - debug
##   - info
##   - warning
##   - error
##   - critical
# c.logging.level.ram = 'debug'

## Duration (in milliseconds) to show messages in the statusbar for. Set
## to 0 to never clear messages.
## Type: Int
# c.messages.timeout = 3000

## How to open links in an existing instance if a new one is launched.
## This happens when e.g. opening a link from a terminal. See
## `new_instance_open_target_window` to customize in which window the
## link is opened in.
## Type: String
## Valid values:
##   - tab: Open a new tab in the existing window and activate the window.
##   - tab-bg: Open a new background tab in the existing window and activate the window.
##   - tab-silent: Open a new tab in the existing window without activating the window.
##   - tab-bg-silent: Open a new background tab in the existing window without activating the window.
##   - window: Open in a new window.
##   - private-window: Open in a new private window.
# c.new_instance_open_target = 'tab'
<<Accept commands from C-c g silently>>

## Which window to choose when opening links as new tabs. When
## `new_instance_open_target` is set to `window`, this is ignored.
## Type: String
## Valid values:
##   - first-opened: Open new tabs in the first (oldest) opened window.
##   - last-opened: Open new tabs in the last (newest) opened window.
##   - last-focused: Open new tabs in the most recently focused window.
##   - last-visible: Open new tabs in the most recently visible window.
# c.new_instance_open_target_window = 'last-focused'

## Show a filebrowser in download prompts.
## Type: Bool
# c.prompt.filebrowser = True

## Rounding radius (in pixels) for the edges of prompts.
## Type: Int
# c.prompt.radius = 8

## Additional arguments to pass to Qt, without leading `--`. With
## QtWebEngine, some Chromium arguments (see
## https://peter.sh/experiments/chromium-command-line-switches/ for a
## list) will work.
## Type: List of String
# c.qt.args = []

## Enables Web Platform features that are in development. This passes the
## `--enable-experimental-web-platform-features` flag to Chromium. By
## default, this is enabled with Qt 5 to maximize compatibility despite
## an aging Chromium base.
## Type: String
## Valid values:
##   - always: Enable experimental web platform features.
##   - auto: Enable experimental web platform features when using Qt 5.
##   - never: Disable experimental web platform features.
# c.qt.chromium.experimental_web_platform_features = 'auto'

## When to use Chromium's low-end device mode. This improves the RAM
## usage of renderer processes, at the expense of performance.
## Type: String
## Valid values:
##   - always: Always use low-end device mode.
##   - auto: Decide automatically (uses low-end mode with < 1 GB available RAM).
##   - never: Never use low-end device mode.
# c.qt.chromium.low_end_device_mode = 'auto'

## Which Chromium process model to use. Alternative process models use
## less resources, but decrease security and robustness. See the
## following pages for more details:    -
## https://www.chromium.org/developers/design-documents/process-models
## - https://doc.qt.io/qt-6/qtwebengine-features.html#process-models
## Type: String
## Valid values:
##   - process-per-site-instance: Pages from separate sites are put into separate processes and separate visits to the same site are also isolated.
##   - process-per-site: Pages from separate sites are put into separate processes. Unlike Process per Site Instance, all visits to the same site will share an OS process. The benefit of this model is reduced memory consumption, because more web pages will share processes. The drawbacks include reduced security, robustness, and responsiveness.
##   - single-process: Run all tabs in a single process. This should be used for debugging purposes only, and it disables `:open --private`.
# c.qt.chromium.process_model = 'process-per-site-instance'

## What sandboxing mechanisms in Chromium to use. Chromium has various
## sandboxing layers, which should be enabled for normal browser usage.
## Mainly for testing and development, it's possible to disable
## individual sandboxing layers via this setting. Open `chrome://sandbox`
## to see the current sandbox status. Changing this setting is only
## recommended if you know what you're doing, as it **disables one of
## Chromium's security layers**. To avoid sandboxing being accidentally
## disabled persistently, this setting can only be set via `config.py`,
## not via `:set`. See the Chromium documentation for more details: - htt
## ps://chromium.googlesource.com/chromium/src/\+/HEAD/docs/linux/sandbox
## ing.md[Linux] - https://chromium.googlesource.com/chromium/src/\+/HEAD
## /docs/design/sandbox.md[Windows] - https://chromium.googlesource.com/c
## hromium/src/\+/HEAD/docs/design/sandbox_faq.md[FAQ (Windows-centric)]
## Type: String
## Valid values:
##   - enable-all: Enable all available sandboxing mechanisms.
##   - disable-seccomp-bpf: Disable the Seccomp BPF filter sandbox (Linux only).
##   - disable-all: Disable all sandboxing (**not recommended!**).
# c.qt.chromium.sandboxing = 'enable-all'

## Additional environment variables to set. Setting an environment
## variable to null/None will unset it.
## Type: Dict
# c.qt.environ = {}

## Force a Qt platform to use. This sets the `QT_QPA_PLATFORM`
## environment variable and is useful to force using the XCB plugin when
## running QtWebEngine on Wayland.
## Type: String
# c.qt.force_platform = None

## Force a Qt platformtheme to use. This sets the `QT_QPA_PLATFORMTHEME`
## environment variable which controls dialogs like the filepicker. By
## default, Qt determines the platform theme based on the desktop
## environment.
## Type: String
# c.qt.force_platformtheme = None

## Force software rendering for QtWebEngine. This is needed for
## QtWebEngine to work with Nouveau drivers and can be useful in other
## scenarios related to graphic issues.
## Type: String
## Valid values:
##   - software-opengl: Tell LibGL to use a software implementation of GL (`LIBGL_ALWAYS_SOFTWARE` / `QT_XCB_FORCE_SOFTWARE_OPENGL`)
##   - qt-quick: Tell Qt Quick to use a software renderer instead of OpenGL. (`QT_QUICK_BACKEND=software`)
##   - chromium: Tell Chromium to disable GPU support and use Skia software rendering instead. (`--disable-gpu`)
##   - none: Don't force software rendering.
# c.qt.force_software_rendering = 'none'

## Turn on Qt HighDPI scaling. This is equivalent to setting
## QT_ENABLE_HIGHDPI_SCALING=1 (Qt >= 5.14) in the environment. It's off
## by default as it can cause issues with some bitmap fonts. As an
## alternative to this, it's possible to set font sizes and the
## `zoom.default` setting.
## Type: Bool
# c.qt.highdpi = False

## Work around locale parsing issues in QtWebEngine 5.15.3. With some
## locales, QtWebEngine 5.15.3 is unusable without this workaround. In
## affected scenarios, QtWebEngine will log "Network service crashed,
## restarting service." and only display a blank page. However, It is
## expected that distributions shipping QtWebEngine 5.15.3 follow up with
## a proper fix soon, so it is disabled by default.
## Type: Bool
# c.qt.workarounds.locale = False

## Delete the QtWebEngine Service Worker directory on every start. This
## workaround can help with certain crashes caused by an unknown
## QtWebEngine bug related to Service Workers. Those crashes happen
## seemingly immediately on Windows; after one hour of operation on other
## systems. Note however that enabling this option *can lead to data
## loss* on some pages (as Service Worker data isn't persisted) and will
## negatively impact start-up time.
## Type: Bool
# c.qt.workarounds.remove_service_workers = False

## When/how to show the scrollbar.
## Type: String
## Valid values:
##   - always: Always show the scrollbar.
##   - never: Never show the scrollbar.
##   - when-searching: Show the scrollbar when searching for text in the webpage. With the QtWebKit backend, this is equal to `never`.
##   - overlay: Show an overlay scrollbar. On macOS, this is unavailable and equal to `when-searching`; with the QtWebKit backend, this is equal to `never`. Enabling/disabling overlay scrollbars requires a restart.
# c.scrolling.bar = 'overlay'
c.scrolling.bar = 'always'

## Enable smooth scrolling for web pages. Note smooth scrolling does not
## work with the `:scroll-px` command.
## Type: Bool
# c.scrolling.smooth = False

## When to find text on a page case-insensitively.
## Type: IgnoreCase
## Valid values:
##   - always: Search case-insensitively.
##   - never: Search case-sensitively.
##   - smart: Search case-sensitively if there are capital characters.
# c.search.ignore_case = 'smart'

## Find text on a page incrementally, renewing the search for each typed
## character.
## Type: Bool
c.search.incremental = True
# ^It might help in preserving scroll position when C-s is started

## Wrap around at the top and bottom of the page when advancing through
## text matches using `:search-next` and `:search-prev`.
## Type: Bool
# c.search.wrap = True

## Display messages when advancing through text matches at the top and
## bottom of the page, e.g. `Search hit TOP`.
## Type: Bool
# c.search.wrap_messages = True

## Name of the session to save by default. If this is set to null, the
## session which was last loaded is saved.
## Type: SessionName
# c.session.default_name = None

## Load a restored tab as soon as it takes focus.
## Type: Bool
# c.session.lazy_restore = False

## Languages to use for spell checking. You can check for available
## languages and install dictionaries using scripts/dictcli.py. Run the
## script with -h/--help for instructions.
## Type: List of String
## Valid values:
##   - af-ZA: Afrikaans (South Africa)
##   - bg-BG: Bulgarian (Bulgaria)
##   - ca-ES: Catalan (Spain)
##   - cs-CZ: Czech (Czech Republic)
##   - da-DK: Danish (Denmark)
##   - de-DE: German (Germany)
##   - el-GR: Greek (Greece)
##   - en-AU: English (Australia)
##   - en-CA: English (Canada)
##   - en-GB: English (United Kingdom)
##   - en-US: English (United States)
##   - es-ES: Spanish (Spain)
##   - et-EE: Estonian (Estonia)
##   - fa-IR: Farsi (Iran)
##   - fo-FO: Faroese (Faroe Islands)
##   - fr-FR: French (France)
##   - he-IL: Hebrew (Israel)
##   - hi-IN: Hindi (India)
##   - hr-HR: Croatian (Croatia)
##   - hu-HU: Hungarian (Hungary)
##   - id-ID: Indonesian (Indonesia)
##   - it-IT: Italian (Italy)
##   - ko: Korean
##   - lt-LT: Lithuanian (Lithuania)
##   - lv-LV: Latvian (Latvia)
##   - nb-NO: Norwegian (Norway)
##   - nl-NL: Dutch (Netherlands)
##   - pl-PL: Polish (Poland)
##   - pt-BR: Portuguese (Brazil)
##   - pt-PT: Portuguese (Portugal)
##   - ro-RO: Romanian (Romania)
##   - ru-RU: Russian (Russia)
##   - sh: Serbo-Croatian
##   - sk-SK: Slovak (Slovakia)
##   - sl-SI: Slovenian (Slovenia)
##   - sq: Albanian
##   - sr: Serbian
##   - sv-SE: Swedish (Sweden)
##   - ta-IN: Tamil (India)
##   - tg-TG: Tajik (Tajikistan)
##   - tr-TR: Turkish (Turkey)
##   - uk-UA: Ukrainian (Ukraine)
##   - vi-VN: Vietnamese (Viet Nam)
# c.spellcheck.languages = []

## Padding (in pixels) for the statusbar.
## Type: Padding
# c.statusbar.padding = {'top': 1, 'bottom': 1, 'left': 0, 'right': 0}

## Position of the status bar.
## Type: VerticalPosition
## Valid values:
##   - top
##   - bottom
# c.statusbar.position = 'bottom'

## When to show the statusbar.
## Type: String
## Valid values:
##   - always: Always show the statusbar.
##   - never: Always hide the statusbar.
##   - in-mode: Show the statusbar when in modes other than normal mode.
#c.statusbar.show = 'always'
<<Status bar visibility>>

## List of widgets displayed in the statusbar.
## Type: List of StatusbarWidget
## Valid values:
##   - url: Current page URL.
##   - scroll: Percentage of the current page position like `10%`.
##   - scroll_raw: Raw percentage of the current page position like `10`.
##   - history: Display an arrow when possible to go back/forward in history.
##   - search_match: A match count when searching, e.g. `Match [2/10]`.
##   - tabs: Current active tab, e.g. `2`.
##   - keypress: Display pressed keys when composing a vi command.
##   - progress: Progress bar for the current page loading.
##   - text:foo: Display the static text after the colon, `foo` in the example.
##   - clock: Display current time. The format can be changed by adding a format string via `clock:...`. For supported format strings, see https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes[the Python datetime documentation].
# c.statusbar.widgets = ['keypress', 'search_match', 'url', 'scroll', 'history', 'tabs', 'progress']
c.statusbar.widgets = ['search_match', 'url', 'history']

## Open new tabs (middleclick/ctrl+click) in the background.
## Type: Bool
# c.tabs.background = True

## Mouse button with which to close tabs.
## Type: String
## Valid values:
##   - right: Close tabs on right-click.
##   - middle: Close tabs on middle-click.
##   - none: Don't close tabs using the mouse.
# c.tabs.close_mouse_button = 'middle'

## How to behave when the close mouse button is pressed on the tab bar.
## Type: String
## Valid values:
##   - new-tab: Open a new tab.
##   - close-current: Close the current tab.
##   - close-last: Close the last tab.
##   - ignore: Don't do anything.
# c.tabs.close_mouse_button_on_bar = 'new-tab'

## Scaling factor for favicons in the tab bar. The tab size is unchanged,
## so big favicons also require extra `tabs.padding`.
## Type: Float
# c.tabs.favicons.scale = 1.0

## When to show favicons in the tab bar. When switching this from never
## to always/pinned, note that favicons might not be loaded yet, thus
## tabs might require a reload to display them.
## Type: String
## Valid values:
##   - always: Always show favicons.
##   - never: Always hide favicons.
##   - pinned: Show favicons only on pinned tabs.
# c.tabs.favicons.show = 'always'
c.tabs.favicons.show = 'never'

## Maximum stack size to remember for tab switches (-1 for no maximum).
## Type: Int
# c.tabs.focus_stack_size = 10

## Padding (in pixels) for tab indicators.
## Type: Padding
# c.tabs.indicator.padding = {'top': 2, 'bottom': 2, 'left': 0, 'right': 4}

## Width (in pixels) of the progress indicator (0 to disable).
## Type: Int
# c.tabs.indicator.width = 3

## How to behave when the last tab is closed. If the
## `tabs.tabs_are_windows` setting is set, this is ignored and the
## behavior is always identical to the `close` value.
## Type: String
## Valid values:
##   - ignore: Don't do anything.
##   - blank: Load a blank page.
##   - startpage: Load the start page.
##   - default-page: Load the default page.
##   - close: Close the window.
# c.tabs.last_close = 'ignore'

## Maximum width (in pixels) of tabs (-1 for no maximum). This setting
## only applies when tabs are horizontal. This setting does not apply to
## pinned tabs, unless `tabs.pinned.shrink` is False. This setting may
## not apply properly if max_width is smaller than the minimum size of
## tab contents, or smaller than tabs.min_width.
## Type: Int
# c.tabs.max_width = -1

## Minimum width (in pixels) of tabs (-1 for the default minimum size
## behavior). This setting only applies when tabs are horizontal. This
## setting does not apply to pinned tabs, unless `tabs.pinned.shrink` is
## False.
## Type: Int
# c.tabs.min_width = -1

## When switching tabs, what input mode is applied.
## Type: String
## Valid values:
##   - persist: Retain the current mode.
##   - restore: Restore previously saved mode.
##   - normal: Always revert to normal mode.
# c.tabs.mode_on_change = 'normal'

## Switch between tabs using the mouse wheel.
## Type: Bool
# c.tabs.mousewheel_switching = True

## Position of new tabs opened from another tab. See
## `tabs.new_position.stacking` for controlling stacking behavior.
## Type: NewTabPosition
## Valid values:
##   - prev: Before the current tab.
##   - next: After the current tab.
##   - first: At the beginning.
##   - last: At the end.
# c.tabs.new_position.related = 'next'

## Stack related tabs on top of each other when opened consecutively.
## Only applies for `next` and `prev` values of
## `tabs.new_position.related` and `tabs.new_position.unrelated`.
## Type: Bool
# c.tabs.new_position.stacking = True

## Position of new tabs which are not opened from another tab. See
## `tabs.new_position.stacking` for controlling stacking behavior.
## Type: NewTabPosition
## Valid values:
##   - prev: Before the current tab.
##   - next: After the current tab.
##   - first: At the beginning.
##   - last: At the end.
# c.tabs.new_position.unrelated = 'last'

## Padding (in pixels) around text for tabs.
## Type: Padding
# c.tabs.padding = {'top': 0, 'bottom': 0, 'left': 5, 'right': 5}

## Force pinned tabs to stay at fixed URL.
## Type: Bool
# c.tabs.pinned.frozen = True

## Shrink pinned tabs down to their contents.
## Type: Bool
# c.tabs.pinned.shrink = True

## Position of the tab bar.
## Type: Position
## Valid values:
##   - top
##   - bottom
##   - left
##   - right
# c.tabs.position = 'top'

## Which tab to select when the focused tab is removed.
## Type: SelectOnRemove
## Valid values:
##   - prev: Select the tab which came before the closed one (left in horizontal, above in vertical).
##   - next: Select the tab which came after the closed one (right in horizontal, below in vertical).
##   - last-used: Select the previously selected tab.
# c.tabs.select_on_remove = 'next'

## When to show the tab bar.
## Type: String
## Valid values:
##   - always: Always show the tab bar.
##   - never: Always hide the tab bar.
##   - multiple: Hide the tab bar if only one tab is open.
##   - switching: Show the tab bar when switching tabs.
# c.tabs.show = 'always'

## Duration (in milliseconds) to show the tab bar before hiding it when
## tabs.show is set to 'switching'.
## Type: Int
# c.tabs.show_switching_delay = 800

## Open a new window for every tab.
## Type: Bool
# c.tabs.tabs_are_windows = False
<<Disable tabs>>

## Alignment of the text inside of tabs.
## Type: TextAlignment
## Valid values:
##   - left
##   - right
##   - center
# c.tabs.title.alignment = 'left'

## Position of ellipsis in truncated title of tabs.
## Type: ElidePosition
## Valid values:
##   - left
##   - right
##   - middle
##   - none
# c.tabs.title.elide = 'right'

## Format to use for the tab title. The following placeholders are
## defined:  * `{perc}`: Percentage as a string like `[10%]`. *
## `{perc_raw}`: Raw percentage, e.g. `10`. * `{current_title}`: Title of
## the current web page. * `{title_sep}`: The string `" - "` if a title
## is set, empty otherwise. * `{index}`: Index of this tab. *
## `{aligned_index}`: Index of this tab padded with spaces to have the
## same   width. * `{relative_index}`: Index of this tab relative to the
## current tab. * `{id}`: Internal tab ID of this tab. * `{scroll_pos}`:
## Page scroll position. * `{host}`: Host of the current web page. *
## `{backend}`: Either `webkit` or `webengine` * `{private}`: Indicates
## when private mode is enabled. * `{current_url}`: URL of the current
## web page. * `{protocol}`: Protocol (http/https/...) of the current web
## page. * `{audio}`: Indicator for audio/mute status.
## Type: FormatString
# c.tabs.title.format = '{audio}{index}: {current_title}'

## Format to use for the tab title for pinned tabs. The same placeholders
## like for `tabs.title.format` are defined.
## Type: FormatString
# c.tabs.title.format_pinned = '{index}'

## Show tooltips on tabs. Note this setting only affects windows opened
## after it has been set.
## Type: Bool
# c.tabs.tooltips = True

## Number of closed tabs (per window) and closed windows to remember for
## :undo (-1 for no maximum).
## Type: Int
# c.tabs.undo_stack_size = 100

## Width (in pixels or as percentage of the window) of the tab bar if
## it's vertical.
## Type: PercOrInt
# c.tabs.width = '15%'

## Wrap when changing tabs.
## Type: Bool
# c.tabs.wrap = True

## What search to start when something else than a URL is entered.
## Type: String
## Valid values:
##   - naive: Use simple/naive check.
##   - dns: Use DNS requests (might be slow!).
##   - never: Never search automatically.
##   - schemeless: Always search automatically unless URL explicitly contains a scheme.
# c.url.auto_search = 'naive'

## Page to open if :open -t/-b/-w is used without URL. Use `about:blank`
## for a blank page.
## Type: FuzzyUrl
# c.url.default_page = 'https://start.duckduckgo.com/'
c.url.default_page = 'about:blank'

## URL segments where `:navigate increment/decrement` will search for a
## number.
## Type: FlagList
## Valid values:
##   - host
##   - port
##   - path
##   - query
##   - anchor
# c.url.incdec_segments = ['path', 'query']

## Open base URL of the searchengine if a searchengine shortcut is
## invoked without parameters.
## Type: Bool
# c.url.open_base_url = False

## Search engines which can be used via the address bar.  Maps a search
## engine name (such as `DEFAULT`, or `ddg`) to a URL with a `{}`
## placeholder. The placeholder will be replaced by the search term, use
## `{{` and `}}` for literal `{`/`}` braces.  The following further
## placeholds are defined to configure how special characters in the
## search terms are replaced by safe characters (called 'quoting'):  *
## `{}` and `{semiquoted}` quote everything except slashes; this is the
## most   sensible choice for almost all search engines (for the search
## term   `slash/and&amp` this placeholder expands to `slash/and%26amp`).
## * `{quoted}` quotes all characters (for `slash/and&amp` this
## placeholder   expands to `slash%2Fand%26amp`). * `{unquoted}` quotes
## nothing (for `slash/and&amp` this placeholder   expands to
## `slash/and&amp`). * `{0}` means the same as `{}`, but can be used
## multiple times.  The search engine named `DEFAULT` is used when
## `url.auto_search` is turned on and something else than a URL was
## entered to be opened. Other search engines can be used by prepending
## the search engine name to the search term, e.g. `:open google
## qutebrowser`.
## Type: Dict
# c.url.searchengines = {'DEFAULT': 'https://duckduckgo.com/?q={}'}
c.url.searchengines = {'DEFAULT': 'https://google.com/search?q={}'}

## Page(s) to open at the start.
## Type: List of FuzzyUrl, or FuzzyUrl
# c.url.start_pages = ['https://start.duckduckgo.com']
c.url.start_pages = ['about:blank']

## URL parameters to strip with `:yank url`.
## Type: List of String
# c.url.yank_ignored_parameters = ['ref', 'utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content', 'utm_name']

## Hide the window decoration.  This setting requires a restart on
## Wayland.
## Type: Bool
# c.window.hide_decoration = False

## Format to use for the window title. The same placeholders like for
## `tabs.title.format` are defined.
## Type: FormatString
#c.window.title_format = '{perc}{current_title}{title_sep}qutebrowser'
c.window.title_format = '{scroll_pos} üûã {current_title}‚Åû{perc}‚Åû{current_url}{title_sep}qutebrowser'

## Set the main window background to transparent.  This allows having a
## transparent tab- or statusbar (might require a compositor such as
## picom). However, it breaks some functionality such as dmenu embedding
## via its `-w` option. On some systems, it was additionally reported
## that main window transparency negatively affects performance.  Note
## this setting only affects windows opened after setting it.
## Type: Bool
# c.window.transparent = False

## Default zoom level.
## Type: Perc
# c.zoom.default = '100%'

## Available zoom levels.
## Type: List of Perc
# c.zoom.levels = ['25%', '33%', '50%', '67%', '75%', '90%', '100%', '110%', '125%', '150%', '175%', '200%', '250%', '300%', '400%', '500%']

## Number of zoom increments to divide the mouse wheel movements to.
## Type: Int
# c.zoom.mouse_divider = 512

## Apply the zoom factor on a frame only to the text or to all content.
## Type: Bool
# c.zoom.text_only = False

## Bindings for normal mode
# config.bind("'", 'mode-enter jump_mark')
# config.bind('+', 'zoom-in')
# config.bind('-', 'zoom-out')
# config.bind('.', 'cmd-repeat-last')
# config.bind('/', 'cmd-set-text /')
# config.bind(':', 'cmd-set-text :')
# config.bind(';I', 'hint images tab')
# config.bind(';O', 'hint links fill :open -t -r {hint-url}')
# config.bind(';R', 'hint --rapid links window')
# config.bind(';Y', 'hint links yank-primary')
# config.bind(';b', 'hint all tab-bg')
# config.bind(';d', 'hint links download')
# config.bind(';f', 'hint all tab-fg')
# config.bind(';h', 'hint all hover')
# config.bind(';i', 'hint images')
# config.bind(';o', 'hint links fill :open {hint-url}')
# config.bind(';r', 'hint --rapid links tab-bg')
# config.bind(';t', 'hint inputs')
# config.bind(';y', 'hint links yank')
# config.bind('<Alt-1>', 'tab-focus 1')
# config.bind('<Alt-2>', 'tab-focus 2')
# config.bind('<Alt-3>', 'tab-focus 3')
# config.bind('<Alt-4>', 'tab-focus 4')
# config.bind('<Alt-5>', 'tab-focus 5')
# config.bind('<Alt-6>', 'tab-focus 6')
# config.bind('<Alt-7>', 'tab-focus 7')
# config.bind('<Alt-8>', 'tab-focus 8')
# config.bind('<Alt-9>', 'tab-focus -1')
# config.bind('<Alt-m>', 'tab-mute')
# config.bind('<Ctrl-A>', 'navigate increment')
# config.bind('<Ctrl-Alt-p>', 'print')
# config.bind('<Ctrl-B>', 'scroll-page 0 -1')
# config.bind('<Ctrl-D>', 'scroll-page 0 0.5')
# config.bind('<Ctrl-F5>', 'reload -f')
# config.bind('<Ctrl-F>', 'scroll-page 0 1')
# config.bind('<Ctrl-N>', 'open -w')
# config.bind('<Ctrl-PgDown>', 'tab-next')
# config.bind('<Ctrl-PgUp>', 'tab-prev')
# config.bind('<Ctrl-Q>', 'quit')
# config.bind('<Ctrl-Return>', 'selection-follow -t')
# config.bind('<Ctrl-Shift-N>', 'open -p')
# config.bind('<Ctrl-Shift-T>', 'undo')
# config.bind('<Ctrl-Shift-Tab>', 'nop')
# config.bind('<Ctrl-Shift-W>', 'close')
# config.bind('<Ctrl-T>', 'open -t')
# config.bind('<Ctrl-Tab>', 'tab-focus last')
# config.bind('<Ctrl-U>', 'scroll-page 0 -0.5')
# config.bind('<Ctrl-V>', 'mode-enter passthrough')
# config.bind('<Ctrl-W>', 'tab-close')
# config.bind('<Ctrl-X>', 'navigate decrement')
# config.bind('<Ctrl-^>', 'tab-focus last')
# config.bind('<Ctrl-h>', 'home')
# config.bind('<Ctrl-p>', 'tab-pin')
# config.bind('<Ctrl-s>', 'stop')
# config.bind('<Escape>', 'clear-keychain ;; search ;; fullscreen --leave')
# config.bind('<F11>', 'fullscreen')
# config.bind('<F5>', 'reload')
# config.bind('<Return>', 'selection-follow')
# config.bind('<back>', 'back')
# config.bind('<forward>', 'forward')
# config.bind('=', 'zoom')
# config.bind('?', 'cmd-set-text ?')
# config.bind('@', 'macro-run')
# config.bind('B', 'cmd-set-text -s :quickmark-load -t')
# config.bind('D', 'tab-close -o')
# config.bind('F', 'hint all tab')
# config.bind('G', 'scroll-to-perc')
# config.bind('H', 'back')
# config.bind('J', 'tab-next')
# config.bind('K', 'tab-prev')
# config.bind('L', 'forward')
# config.bind('M', 'bookmark-add')
# config.bind('N', 'search-prev')
# config.bind('O', 'cmd-set-text -s :open -t')
# config.bind('PP', 'open -t -- {primary}')
# config.bind('Pp', 'open -t -- {clipboard}')
# config.bind('R', 'reload -f')
# config.bind('Sb', 'bookmark-list --jump')
# config.bind('Sh', 'history')
# config.bind('Sq', 'bookmark-list')
# config.bind('Ss', 'set')
# config.bind('T', 'cmd-set-text -sr :tab-focus')
# config.bind('U', 'undo -w')
# config.bind('V', 'mode-enter caret ;; selection-toggle --line')
# config.bind('ZQ', 'quit')
# config.bind('ZZ', 'quit --save')
# config.bind('[[', 'navigate prev')
# config.bind(']]', 'navigate next')
# config.bind('`', 'mode-enter set_mark')
# config.bind('ad', 'download-cancel')
# config.bind('b', 'cmd-set-text -s :quickmark-load')
# config.bind('cd', 'download-clear')
# config.bind('co', 'tab-only')
# config.bind('d', 'tab-close')
# config.bind('f', 'hint')
# config.bind('g$', 'tab-focus -1')
# config.bind('g0', 'tab-focus 1')
# config.bind('gB', 'cmd-set-text -s :bookmark-load -t')
# config.bind('gC', 'tab-clone')
# config.bind('gD', 'tab-give')
# config.bind('gJ', 'tab-move +')
# config.bind('gK', 'tab-move -')
# config.bind('gO', 'cmd-set-text :open -t -r {url:pretty}')
# config.bind('gU', 'navigate up -t')
# config.bind('g^', 'tab-focus 1')
# config.bind('ga', 'open -t')
# config.bind('gb', 'cmd-set-text -s :bookmark-load')
# config.bind('gd', 'download')
# config.bind('gf', 'view-source')
# config.bind('gg', 'scroll-to-perc 0')
# config.bind('gi', 'hint inputs --first')
# config.bind('gm', 'tab-move')
# config.bind('go', 'cmd-set-text :open {url:pretty}')
# config.bind('gt', 'cmd-set-text -s :tab-select')
# config.bind('gu', 'navigate up')
# config.bind('h', 'scroll left')
# config.bind('i', 'mode-enter insert')
# config.bind('j', 'scroll down')
# config.bind('k', 'scroll up')
# config.bind('l', 'scroll right')
# config.bind('m', 'quickmark-save')
# config.bind('n', 'search-next')
# config.bind('o', 'cmd-set-text -s :open')
# config.bind('pP', 'open -- {primary}')
# config.bind('pp', 'open -- {clipboard}')
# config.bind('q', 'macro-record')
# config.bind('r', 'reload')
# config.bind('sf', 'save')
# config.bind('sk', 'cmd-set-text -s :bind')
# config.bind('sl', 'cmd-set-text -s :set -t')
# config.bind('ss', 'cmd-set-text -s :set')
# config.bind('tCH', 'config-cycle -p -u *://*.{url:host}/* content.cookies.accept all no-3rdparty never ;; reload')
# config.bind('tCh', 'config-cycle -p -u *://{url:host}/* content.cookies.accept all no-3rdparty never ;; reload')
# config.bind('tCu', 'config-cycle -p -u {url} content.cookies.accept all no-3rdparty never ;; reload')
# config.bind('tIH', 'config-cycle -p -u *://*.{url:host}/* content.images ;; reload')
# config.bind('tIh', 'config-cycle -p -u *://{url:host}/* content.images ;; reload')
# config.bind('tIu', 'config-cycle -p -u {url} content.images ;; reload')
# config.bind('tPH', 'config-cycle -p -u *://*.{url:host}/* content.plugins ;; reload')
# config.bind('tPh', 'config-cycle -p -u *://{url:host}/* content.plugins ;; reload')
# config.bind('tPu', 'config-cycle -p -u {url} content.plugins ;; reload')
# config.bind('tSH', 'config-cycle -p -u *://*.{url:host}/* content.javascript.enabled ;; reload')
# config.bind('tSh', 'config-cycle -p -u *://{url:host}/* content.javascript.enabled ;; reload')
# config.bind('tSu', 'config-cycle -p -u {url} content.javascript.enabled ;; reload')
# config.bind('tcH', 'config-cycle -p -t -u *://*.{url:host}/* content.cookies.accept all no-3rdparty never ;; reload')
# config.bind('tch', 'config-cycle -p -t -u *://{url:host}/* content.cookies.accept all no-3rdparty never ;; reload')
# config.bind('tcu', 'config-cycle -p -t -u {url} content.cookies.accept all no-3rdparty never ;; reload')
# config.bind('th', 'back -t')
# config.bind('tiH', 'config-cycle -p -t -u *://*.{url:host}/* content.images ;; reload')
# config.bind('tih', 'config-cycle -p -t -u *://{url:host}/* content.images ;; reload')
# config.bind('tiu', 'config-cycle -p -t -u {url} content.images ;; reload')
# config.bind('tl', 'forward -t')
# config.bind('tpH', 'config-cycle -p -t -u *://*.{url:host}/* content.plugins ;; reload')
# config.bind('tph', 'config-cycle -p -t -u *://{url:host}/* content.plugins ;; reload')
# config.bind('tpu', 'config-cycle -p -t -u {url} content.plugins ;; reload')
# config.bind('tsH', 'config-cycle -p -t -u *://*.{url:host}/* content.javascript.enabled ;; reload')
# config.bind('tsh', 'config-cycle -p -t -u *://{url:host}/* content.javascript.enabled ;; reload')
# config.bind('tsu', 'config-cycle -p -t -u {url} content.javascript.enabled ;; reload')
# config.bind('u', 'undo')
# config.bind('v', 'mode-enter caret')
# config.bind('wB', 'cmd-set-text -s :bookmark-load -w')
# config.bind('wIf', 'devtools-focus')
# config.bind('wIh', 'devtools left')
# config.bind('wIj', 'devtools bottom')
# config.bind('wIk', 'devtools top')
# config.bind('wIl', 'devtools right')
# config.bind('wIw', 'devtools window')
# config.bind('wO', 'cmd-set-text :open -w {url:pretty}')
# config.bind('wP', 'open -w -- {primary}')
# config.bind('wb', 'cmd-set-text -s :quickmark-load -w')
# config.bind('wf', 'hint all window')
# config.bind('wh', 'back -w')
# config.bind('wi', 'devtools')
# config.bind('wl', 'forward -w')
# config.bind('wo', 'cmd-set-text -s :open -w')
# config.bind('wp', 'open -w -- {clipboard}')
# config.bind('xO', 'cmd-set-text :open -b -r {url:pretty}')
# config.bind('xo', 'cmd-set-text -s :open -b')
# config.bind('yD', 'yank domain -s')
# config.bind('yM', 'yank inline [{title}]({url}) -s')
# config.bind('yP', 'yank pretty-url -s')
# config.bind('yT', 'yank title -s')
# config.bind('yY', 'yank -s')
# config.bind('yd', 'yank domain')
# config.bind('ym', 'yank inline [{title}]({url})')
# config.bind('yp', 'yank pretty-url')
# config.bind('yt', 'yank title')
# config.bind('yy', 'yank')
# config.bind('{{', 'navigate prev -t')
# config.bind('}}', 'navigate next -t')

## Bindings for caret mode
# config.bind('$', 'move-to-end-of-line', mode='caret')
# config.bind('0', 'move-to-start-of-line', mode='caret')
# config.bind('<Ctrl-Space>', 'selection-drop', mode='caret')
# config.bind('<Escape>', 'mode-leave', mode='caret')
# config.bind('<Return>', 'yank selection', mode='caret')
# config.bind('<Space>', 'selection-toggle', mode='caret')
# config.bind('G', 'move-to-end-of-document', mode='caret')
# config.bind('H', 'scroll left', mode='caret')
# config.bind('J', 'scroll down', mode='caret')
# config.bind('K', 'scroll up', mode='caret')
# config.bind('L', 'scroll right', mode='caret')
# config.bind('V', 'selection-toggle --line', mode='caret')
# config.bind('Y', 'yank selection -s', mode='caret')
# config.bind('[', 'move-to-start-of-prev-block', mode='caret')
# config.bind(']', 'move-to-start-of-next-block', mode='caret')
# config.bind('b', 'move-to-prev-word', mode='caret')
# config.bind('c', 'mode-enter normal', mode='caret')
# config.bind('e', 'move-to-end-of-word', mode='caret')
# config.bind('gg', 'move-to-start-of-document', mode='caret')
# config.bind('h', 'move-to-prev-char', mode='caret')
# config.bind('j', 'move-to-next-line', mode='caret')
# config.bind('k', 'move-to-prev-line', mode='caret')
# config.bind('l', 'move-to-next-char', mode='caret')
# config.bind('o', 'selection-reverse', mode='caret')
# config.bind('v', 'selection-toggle', mode='caret')
# config.bind('w', 'move-to-next-word', mode='caret')
# config.bind('y', 'yank selection', mode='caret')
# config.bind('{', 'move-to-end-of-prev-block', mode='caret')
# config.bind('}', 'move-to-end-of-next-block', mode='caret')

## Bindings for command mode
# config.bind('<Alt-B>', 'rl-backward-word', mode='command')
# config.bind('<Alt-Backspace>', 'rl-backward-kill-word', mode='command')
# config.bind('<Alt-D>', 'rl-kill-word', mode='command')
# config.bind('<Alt-F>', 'rl-forward-word', mode='command')
# config.bind('<Ctrl-?>', 'rl-delete-char', mode='command')
# config.bind('<Ctrl-A>', 'rl-beginning-of-line', mode='command')
# config.bind('<Ctrl-B>', 'rl-backward-char', mode='command')
# config.bind('<Ctrl-C>', 'completion-item-yank', mode='command')
# config.bind('<Ctrl-D>', 'completion-item-del', mode='command')
# config.bind('<Ctrl-E>', 'rl-end-of-line', mode='command')
# config.bind('<Ctrl-F>', 'rl-forward-char', mode='command')
# config.bind('<Ctrl-H>', 'rl-backward-delete-char', mode='command')
# config.bind('<Ctrl-K>', 'rl-kill-line', mode='command')
# config.bind('<Ctrl-N>', 'command-history-next', mode='command')
# config.bind('<Ctrl-P>', 'command-history-prev', mode='command')
# config.bind('<Ctrl-Return>', 'command-accept --rapid', mode='command')
# config.bind('<Ctrl-Shift-C>', 'completion-item-yank --sel', mode='command')
# config.bind('<Ctrl-Shift-Tab>', 'completion-item-focus prev-category', mode='command')
# config.bind('<Ctrl-Shift-W>', 'rl-filename-rubout', mode='command')
# config.bind('<Ctrl-Tab>', 'completion-item-focus next-category', mode='command')
# config.bind('<Ctrl-U>', 'rl-unix-line-discard', mode='command')
# config.bind('<Ctrl-W>', 'rl-rubout " "', mode='command')
# config.bind('<Ctrl-Y>', 'rl-yank', mode='command')
# config.bind('<Down>', 'completion-item-focus --history next', mode='command')
# config.bind('<Escape>', 'mode-leave', mode='command')
# config.bind('<PgDown>', 'completion-item-focus next-page', mode='command')
# config.bind('<PgUp>', 'completion-item-focus prev-page', mode='command')
# config.bind('<Return>', 'command-accept', mode='command')
# config.bind('<Shift-Delete>', 'completion-item-del', mode='command')
# config.bind('<Shift-Tab>', 'completion-item-focus prev', mode='command')
# config.bind('<Tab>', 'completion-item-focus next', mode='command')
# config.bind('<Up>', 'completion-item-focus --history prev', mode='command')

## Bindings for hint mode
# config.bind('<Ctrl-B>', 'hint all tab-bg', mode='hint')
# config.bind('<Ctrl-F>', 'hint links', mode='hint')
# config.bind('<Ctrl-R>', 'hint --rapid links tab-bg', mode='hint')
# config.bind('<Escape>', 'mode-leave', mode='hint')
# config.bind('<Return>', 'hint-follow', mode='hint')

## Bindings for insert mode
# config.bind('<Ctrl-E>', 'edit-text', mode='insert')
# config.bind('<Escape>', 'mode-leave', mode='insert')
# config.bind('<Shift-Escape>', 'fake-key <Escape>', mode='insert')
# config.bind('<Shift-Ins>', 'insert-text -- {primary}', mode='insert')

## Bindings for passthrough mode
# config.bind('<Shift-Escape>', 'mode-leave', mode='passthrough')

## Bindings for prompt mode
# config.bind('<Alt-B>', 'rl-backward-word', mode='prompt')
# config.bind('<Alt-Backspace>', 'rl-backward-kill-word', mode='prompt')
# config.bind('<Alt-D>', 'rl-kill-word', mode='prompt')
# config.bind('<Alt-E>', 'prompt-fileselect-external', mode='prompt')
# config.bind('<Alt-F>', 'rl-forward-word', mode='prompt')
# config.bind('<Alt-Shift-Y>', 'prompt-yank --sel', mode='prompt')
# config.bind('<Alt-Y>', 'prompt-yank', mode='prompt')
# config.bind('<Ctrl-?>', 'rl-delete-char', mode='prompt')
# config.bind('<Ctrl-A>', 'rl-beginning-of-line', mode='prompt')
# config.bind('<Ctrl-B>', 'rl-backward-char', mode='prompt')
# config.bind('<Ctrl-E>', 'rl-end-of-line', mode='prompt')
# config.bind('<Ctrl-F>', 'rl-forward-char', mode='prompt')
# config.bind('<Ctrl-H>', 'rl-backward-delete-char', mode='prompt')
# config.bind('<Ctrl-K>', 'rl-kill-line', mode='prompt')
# config.bind('<Ctrl-P>', 'prompt-open-download --pdfjs', mode='prompt')
# config.bind('<Ctrl-Shift-W>', 'rl-filename-rubout', mode='prompt')
# config.bind('<Ctrl-U>', 'rl-unix-line-discard', mode='prompt')
# config.bind('<Ctrl-W>', 'rl-rubout " "', mode='prompt')
# config.bind('<Ctrl-X>', 'prompt-open-download', mode='prompt')
# config.bind('<Ctrl-Y>', 'rl-yank', mode='prompt')
# config.bind('<Down>', 'prompt-item-focus next', mode='prompt')
# config.bind('<Escape>', 'mode-leave', mode='prompt')
# config.bind('<Return>', 'prompt-accept', mode='prompt')
# config.bind('<Shift-Tab>', 'prompt-item-focus prev', mode='prompt')
# config.bind('<Tab>', 'prompt-item-focus next', mode='prompt')
# config.bind('<Up>', 'prompt-item-focus prev', mode='prompt')

## Bindings for register mode
# config.bind('<Escape>', 'mode-leave', mode='register')

## Bindings for yesno mode
# config.bind('<Alt-Shift-Y>', 'prompt-yank --sel', mode='yesno')
# config.bind('<Alt-Y>', 'prompt-yank', mode='yesno')
# config.bind('<Escape>', 'mode-leave', mode='yesno')
# config.bind('<Return>', 'prompt-accept', mode='yesno')
# config.bind('N', 'prompt-accept --save no', mode='yesno')
# config.bind('Y', 'prompt-accept --save yes', mode='yesno')
# config.bind('n', 'prompt-accept no', mode='yesno')
# config.bind('y', 'prompt-accept yes', mode='yesno')

<<emacs-keybindings1>>
<<Set default zoom level>>
<<My custom fonts>>
#+end_src

