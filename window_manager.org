* exwm main heading
** line-mode vs char-mode
I almost always use exwm in *line-mode*
In *char-mode* all key presses are sent directly to the X11 application, as if EXWM isnt interfering at all
This sub-mode is displayed in the modeline, next to the exwm major mode. Clicking on it toggles between them

** exwm one major shortcoming
Cannot set DPI per monitor. Every monitor must be configured to have the same DPI.

** non emacs system config files
;; dbus-launch is already installed as dependency of systemd
;; gnome-settings-daemon or xfce equivalent - skip for now

;; cat /usr/share/xsessions/emacs.desktop
[Desktop Entry]
Name=Emacs
Exec=emacs
Type=Application

;; cat ~/.xinitrc
#+begin_src shell
# Disable access control for the current user.
xhost +SI:localuser:$USER

# Make Java applications aware this is a non-reparenting window manager.
export _JAVA_AWT_WM_NONREPARENTING=1

# Set default cursor.
xsetroot -cursor_name left_ptr

# Set keyboard repeat rate.
xset r rate 200 60

# Uncomment the following block to use the exwm-xim module.
#export XMODIFIERS=@im=exwm-xim
#export GTK_IM_MODULE=xim
#export QT_IM_MODULE=xim
#export CLUTTER_IM_MODULE=xim

# Finally start Emacs
exec emacs & wmpid=$!
sleep 5
/home/anoop/scripts/emods.sh
wait $wmpid
#+end_src
** keybind my customized ~other-window~
=C-x o= & =M-o= should cycle through windows from all visible frames, NOT just the current frame
This makes buffer switching on multiple monitor setup at bidare  intuitive

~anup/other-window~ is defined in [[*clever approach to fix above problem][exwm multi monitor workaround]]

#+begin_src emacs-lisp :noweb-ref "Bind anup/other-window"
(bind-keys :map global-map
           ("M-o" . anup/other-window)
           ("C-x o" . anup/other-window))
#+end_src
#+begin_src emacs-lisp :tangle window_manager.el
<<Bind anup/other-window>>
#+end_src
Above block look unnecessary. But it enables me to reuse <<Bind anup/other-window>> elsewhere too.

+Someday, ~anup/other-window~ can be replace by builtin ~next-window-any-frame~.+  It doesnt respect ~treemacs-is-never-other-window~, unlike ~other-window~ which does.
Unfortunately, both of these dont support negative prefix argument to reverse direction, unlike ~other-window~

Doubt, why does the implementation of ~next-window-any-frame~  contain some code for input focus setting?

TODO:-
~anup/other-window~ makes the assumption that total number of windows is 3. One per hardware-monitor.
If there are more than 3 virtual-windows, then there is a BUG. fixme.

** COMMENT set window focus to follow mouse movement
Have disabled this because this is an anti-thesis to the exwm-mff package's ideals

This is here because
This needs to happen even BEFORE loading exwm, according to the exwm readme
#+begin_src emacs-lisp :tangle window_manager.el
;;auto-raise:-
(setq mouse-autoselect-window t)
(setq focus-follows-mouse 'auto-raise)
  #+end_src

*** TODO COMMENT (INCOMPLETE) mouse focus hack
X11 applications sometimes do not get input focus when they are
created, or when one switches between buffers containing X11
applications, in the same emacs frame. This is probably an EXWM bug.
The workaround is to move out of the window, and back again.

Running other-window with a skip equal to the number of current
windows will lead to mouse focus cycling back to current window.
This therefore achieves our hack using elisp.

Does this bug, the sub-bug that affects copy/paste from X app to emacs occur only subsequent to
emacs C-k some sentence or pastable entity, ie C-k ring full0 in emacs

**** COMMENT try1
#+begin_src emacs-lisp :tangle window_manager.el
(defadvice switch-to-buffer (after mouse_selection_hack4 activate)
  ;;(call-interactively #'my-other-window)
  ;;(dotimes (_ (count-windows nil t)))
  (progn
    (message "switch-to-buffer received run mouse focus hack4")
    (other-window (count-windows nil t))
    ))

#+end_src
^ This will enable me to NOT have to click into google chrome window to enable scrolling up/down using C-v & M-v

**** COMMENT try2
#+begin_src emacs-lisp :tangle window_manager.el
(defadvice switch-to-buffer (after mouse_selection_hack8 activate)
  (progn
    (dotimes (_ (count-windows nil t))
      (call-interactively #'my-other-window))
    (message "switch-to-buffer received hack8")
    ))

#+end_src

** exwm use-package
#+begin_src emacs-lisp :tangle window_manager.el
(use-package exwm
  :if (display-graphic-p)
  :vc (:url "https://github.com/emacs-exwm/exwm" :rev :newest)
  :init
  ;; moved to using polybar
  ;; ;;system tray, to show dropbox etc, must be configured before (exwm-wm-mode +1). aka: dock, bottom system panel
  ;;(require 'exwm-systemtray)
  ;;(exwm-systemtray-mode +1)
  
  (require 'exwm)
  (setq exwm-layout-show-all-buffers t)
  ;;(require 'exwm-config)
  <<xcb timeout settings>>
  <<Exwm init>>
  :hook
  ;;Without below renaming, you may see the X buffer names being generically named '*EXWM*' which is confusing
  ;;Below will add the app name to X buffer names
  
  ;;An explicit " -- exwm-class-name" is required because obscure X apps such as,-
  ;;-such as qBittorrent sometimes dont add their appname to all their windows
  ;;whereas Google Chrome and Qutebrowser, by default, already include their classname in their title.
  (exwm-update-title . (lambda ()
                         (if (or (string= exwm-class-name "qutebrowser")
                                 (string= exwm-class-name "Google-chrome"))
                             (exwm-workspace-rename-buffer exwm-title)
                           (exwm-workspace-rename-buffer (concat exwm-title " -- " exwm-class-name)))))

  ;;per application settings
  :hook
  (exwm-manage-finish . (lambda ()
                          ;; (when (and exwm-class-name
                          ;;            (string= exwm-class-name "Google-chrome"))
                          ;;   (exwm-input-set-local-simulation-keys
                          ;;    (cl-concatenate 'list
                          ;;                 exwm-input-simulation-keys
			  ;;       	  `((,(kbd "M-b") . ,(kbd "<XF86Back>"))
			  ;;       	    (,(kbd "M-f") . ,(kbd "<XF86Forward>"))
			  ;;       	    (,(kbd "C-g") . ,(kbd "ESC"))))))
                          
			  ;;disable all simulation keys for some app:-
                          (when (and exwm-class-name
                                     (or
                                      (string= exwm-class-name "Nyxt")))
                            (exwm-input-set-local-simulation-keys nil))))
  :hook
  (<<exwm/hook>>)
  :bind
  (<<Exwm bindings>>
          :map exwm-mode-map
          <<Bindings inside exwm-mode-map>>)
  :config
  <<Exwm config>>
  (fringe-mode '(8 . 8))                ;make both left and right fringe 8 px wide
  ;;(scroll-bar-mode 0)
  (menu-bar-mode 0)

  (setq exwm-input-simulation-keys
        `(;; movement
          (,(kbd "M-b") . C-left)
          (,(kbd "M-f") . C-right)
          (,(kbd "M-v") . prior)
          (,(kbd "C-v") . next)
          (,(kbd "C-d") . delete)
          (,(kbd "M-d") . backspace)

          <<Add to exwm-input-simulation-keys>>))
  
  (setq exwm-input-global-keys
        `(
          ;; Enter line mode and redirect input to emacs
          ([?\s-n] . (lambda () (interactive)
                       (exwm-reset)
                       (setq exwm-input-line-mode-passthrough t)))

          ;; Only enter line mode
          ([?\s-N] . (lambda () (interactive)
                       (exwm-reset)
                       (setq exwm-input-line-mode-passthrough nil)))

          ;; enter char-mode again
          ([?\s-i] . exwm-input-release-keyboard)
          ([?\s-w] . exwm-workspace-switch)
          ([?\s-&] . (lambda (command)
                       (interactive (list (read-shell-command "$ ")))
                       (start-process-shell-command command nil command)))

          ([?\M-o] . anup/other-window)

          ;;(,(kbd "M-y") . helm-show-kill-ring)
          ;;switched away from helm kill ring browser^ to this:-
          (,(kbd "M-y") . browse-kill-ring)
          
          (,(kbd "M-!") . shell-command)
          (,(kbd "<XF86Back>") . previous-buffer)
          (,(kbd "<XF86Forward>") . next-buffer)

          ;;;; Below causes problems with char-mode for Edwin editor
          ;;;;([key-4660] . ignore) ;; emods workaround, causes problems to Edwin
          ))

  ;;;;Make chrome buffer name equal to its title value
  ;;guide:- https://teddit.net/r/emacs/comments/mb8u1m/weekly_tipstricketc_thread/gs55kqw/

  ;;needs this chrome extension for to even include 'url' in chrome tab title
  ;;this extension is open source
  ;;https://chrome.google.com/webstore/detail/url-in-title/ignpacbgnbnkaiooknalneoeladjnfgb/related?hl=en

  ;;needs this chrome extension to by default open links in new window instead of new tab
  ;;https://chrome.google.com/webstore/detail/new-tab-new-window/dndlcbaomdoggooaficldplkcmkfpgff


  ;;custom keybindings for Google Chrome
  ;;source:- https://github.com/ch11ng/exwm/wiki#how-to-send-c-c-to-term
  ;;below has a bug, instead of setting =exwm-input-set-local-simulation-keys=,
  ;;-I should have added to existing set of =exwm-input-set-local-simulation-keys=
  ;;I have tried to solve this bug using cons, see if this bugfix works on restart
  (add-hook 'exwm-manage-finish-hook
            (lambda ()
              (when (and exwm-class-name
                         (string= exwm-class-name "Google-chrome"))
                (exwm-input-set-local-simulation-keys (cons '([?\C-r] . ?\C-r) exwm-input-simulation-keys))
                (exwm-input-set-local-simulation-keys (cons '([f5] . ?\C-r) exwm-input-simulation-keys))
                ;;M-w should copy
                (exwm-input-set-local-simulation-keys (cons '([?\M-w] . ?\C-c) exwm-input-simulation-keys))))))
#+end_src

Below enables exwm. This needs to be called after I have set my exwm xrandr settings. To play it safe, let me place it at the bottom of my config.
#+begin_src emacs-lisp :noweb-ref "Bottom of new.org file"
(exwm-wm-mode +1)
#+end_src

Temporary, this fixes an unknown bug in x220 laptop, which makes exwm not launch. Above block probably fixes this too. If so, remove below block.
#+begin_src emacs-lisp :noweb-ref "laptop only"
(exwm-init)
#+end_src

** Move X application to other monitor

#+begin_src emacs-lisp :noweb-ref "Exwm bindings"
;;("C-c p" . helm-run-external-command)
("C-c p" . anoop/counsel-linux-app)
;;("C-c p" . app-launcher-run-app)
#+end_src

TODO Below keybindings are currently not working in X-windows for some reason
#+begin_src emacs-lisp :noweb-ref "Exwm bindings"
("M-y" . browse-kill-ring)
("<XF86Back>" . previous-buffer)
("<XF86Forward>" . next-buffer)
("M-!" . shell-command)
#+end_src

** Disable some keybindings that I never use
This removes the following from =exwm-mode-map=:
- Toggling fullscreen
- Toggling floating
- Toggling hiding
- Toggling the mode line
#+begin_src emacs-lisp :noweb-ref "Bindings inside exwm-mode-map"
("C-c C-f" . nil)
("C-c C-t C-f" . nil)
("C-c C-t C-v" . nil)
("C-c C-t C-m" . nil)
#+end_src
** Always start Edwin and Visual Studio Code in char-mode
#+begin_src emacs-lisp :noweb-ref "Exwm config"
;;; Some programs such as 'edwin' are better off being started in char-mode.
(defun ambrevar/exwm-start-in-char-mode ()
  (when (or (string-prefix-p "edwin" exwm-instance-name) (string-prefix-p "code" exwm-instance-name))
    (exwm-input-release-keyboard (exwm--buffer->id (window-buffer)))))
(add-hook 'exwm-manage-finish-hook 'ambrevar/exwm-start-in-char-mode)
#+end_src
** Send a key verbatim more easily
By default this was bound to =C-c C-q=
This means there's one less key needed to send a verbatim key to an EXWM
buffer.  It is bound in =exwm-mode-map=.
#+begin_src emacs-lisp :noweb-ref "Bindings inside exwm-mode-map"
  ("C-q" . exwm-input-send-next-key)
  ("C-c C-q" . nil)
#+end_src

** A function to apply changes to exwm-input-global-keys
stolen from [[https://sqrtminusone.xyz/configs/desktop/][Desktop]]
#+begin_src emacs-lisp :tangle window_manager.el
(defun my/exwm-update-global-keys ()
  (interactive)
  (setq exwm-input--global-keys nil)
  (dolist (i exwm-input-global-keys)
    (exwm-input--set-key (car i) (cdr i)))
  (when exwm--connection
    (exwm-input--update-global-prefix-keys)))
#+end_src

** COMMENT volume control
#+begin_quote Currently not working due to this bug
Autoloading file /home/anoop/.emacs.d/elpa/pulseaudio-control-20230316.1819/pulseaudio-control.elc failed to define function pulseaudio-control-increase-volume
#+end_quote

#+begin_src emacs-lisp :tangle window_manager.el
(use-package pulseaudio-control
  :bind (("<XF86AudioRaiseVolume>" . pulseaudio-control-increase-volume)
         ("<XF86AudioLowerVolume>" . pulseaudio-control-decrease-volume)
         ("<XF86AudioMute>" . pulseaudio-control-toggle-current-sink-mute)
	 ("<XF86AudioMicMute>" . pulseaudio-control-toggle-current-source-mute))
  :config
  (setq pulseaudio-control-volume-step "5%"))
#+end_src
** COMMENT volume control on X220
disabled because it was too jittery for some reason.
For now, I have set these keys to vuiet volume control.
#+begin_src emacs-lisp :tangle window_manager.el
(global-set-key (kbd "<XF86AudioRaiseVolume>")
                (lambda () (interactive) (shell-command "pamixer --allow-boost --increase 5")))
(global-set-key (kbd "<XF86AudioLowerVolume>")
                (lambda () (interactive) (shell-command "pamixer --allow-boost --decrease 5")))
(global-set-key (kbd "<XF86AudioMute>")
                (lambda () (interactive) (shell-command "pamixer --toggle-mute")))
#+end_src
** hide mouse cursor when not in use
pacman -S unclutter
Add this config to ~/.xinitrc :-
#+begin_src 
unclutter -idle 2 &
#+end_src
** mouse focus should follow keyboard
When I do M-o through keyboard, the mouse cursor should move to the newly selected window
In other words, mouse follows the windows focussed using keyboard
#+begin_src emacs-lisp :tangle window_manager.el
(use-package exwm-mff
  :if (display-graphic-p)
  :config
  (exwm-mff-mode))
#+end_src

#+begin_quote I suspect this package may be causing the bug:-
Error running timer ‘exwm-input--update-focus-commit’: (wrong-type-argument window-live-p nil)
#+end_quote

Let me try updating above package
#+begin_src emacs-lisp :tangle window_manager.el
(use-package exwm-mff
  :vc (:url "https://codeberg.org/emacs-weirdware/exwm-mff.git")
  :if (display-graphic-p)
  :config
  (exwm-mff-mode))
#+end_src

Still facing above bug,
Will redefining ~(defun exwm-input--update-focus (window)~ function to skip window-live-p checking work?
I tried that^, didnt work
** COMMENT edit textareas using emacs in any app on exwm
This is still buggy
Use C-c C-' and C-c C-c to edit with emacs from any X app
#+begin_src emacs-lisp :tangle window_manager.el
(use-package exwm-edit
  :config
  (defun anoopemacs/on-exwm-edit-compose ()
    (funcall 'python-mode))
  (add-hook 'exwm-edit-compose-hook #'anoopemacs/on-exwm-edit-compose))
#+end_src

** Auto start dropbox if using on linux & exwm
+^Disabled on X220, because I want to force a sync from online Dropbox to X220+
+ie, I want to force replace local job.org with the version found on online Dropbox+
+Because,  I foolishly made some minor edits to an outdated job.org locally.+
+I should instead have first done a sync, before making those edits.+
+I am OK with losing these minor edits. But I am *NOT* Ok with losing items from online version of job.org+

Henceforth, I will make a rule to use  ONLY the =~/Dropbox/x220.org= whenever I am editing on X220 laptop.
ie, I will never touch =job.org= file, anywhere except the mother ship, the iMac-5K.

#+begin_src emacs-lisp :tangle window_manager.el
(if (eq system-type 'gnu/linux)
    (run-with-timer 5
                  nil
                  (lambda () (call-process-shell-command "/usr/bin/dropbox start &" nil 0))))
#+end_src
^Wait for 5 seconds for the systemtray to start. This ensure dropbox is started *after* exwm-systemtray or polybar.

** Auto start the drawing tablet driver
The tablet doesnt recognize that my second monitor is rotated 90 degrees.
I need to either replug the usb wire of the tablet or simulate the same using /usbreset/ to fix this.

~lsusb~ shows that my drawing tablet's usb id is =28bd:0905=
This id is used as input to /usbreset/

The driver complains if not started as /root/
unfortunately this results in my sudo password being visible in my emacs config
#+begin_src emacs-lisp :tangle window_manager.el
(defun pen-tablet-reload ()
  (interactive)
  ;;if already running, kill it
  (call-process-shell-command "echo jjf | sudo -S pkill PenTablet" nil 0)
  ;;wait for 2 seconds for the kill to complete, before running next command
  (run-with-timer 2
                  nil
                  (lambda () (call-process-shell-command "echo jjf | sudo -S /usr/lib/pentablet/PenTablet.sh &" nil 0)))
  ;;bury the PenTablet settings window after it starts. I have a doubt on what to pass as the buffer name
  (run-with-timer 7
                  nil
                  (lambda ()
                    (switch-to-buffer
                     ;;The space is needed if the buffer is on another frame
                     (or (get-buffer "Pentablet -- PenTablet") (get-buffer " Pentablet -- PenTablet")))
                    ;;(bury-buffer)                         ;did not work
                    ;;Lets indirectly bury this buffer by switching to the scratch buffer as the active buffer
                    (switch-to-buffer "*scratch*"))))

(defalias 'pentablet-reload 'pen-tablet-reload)
(defalias 'drawing-tablet-reload 'pen-tablet-reload)
#+end_src


Do call it once during bootup.
#+begin_src emacs-lisp :tangle window_manager.el
(if (and (equal system-name "imac0") (display-graphic-p))
    (progn
      ;;Below is the equivalent of unplugging and replugging the usb cable connecting the tablet
      (shell-command "usbreset 28bd:0905")

      ;;wait for 5 seconds for reset to complete
      (run-with-timer 5
                nil
                'pen-tablet-reload)))
#+end_src

Shouldnt I move the ~usbreset~ call into the ~pen-tablet-reload~ function itself?
** Auto start nm-applet
#+begin_src emacs-lisp :tangle window_manager.el
(if (eq system-type 'gnu/linux)
    (run-with-timer 7
                  nil
                  (lambda () (call-process-shell-command "nm-applet &" nil 0))))
#+end_src
** COMMENT helm-exwm
This shows emacs buffers separate from the exwm buffers
#+begin_src emacs-lisp :tangle window_manager.el
(use-package helm-exwm
  ;; :bind ("C-x C-b" . helm-mini)
  :config
  (setq helm-exwm-emacs-buffers-source (helm-exwm-build-emacs-buffers-source))
  (setq helm-exwm-source (helm-exwm-build-source))
  (setq helm-mini-default-sources `(helm-exwm-emacs-buffers-source
                                    helm-exwm-source
                                    helm-source-recentf)))
#+end_src

** TODO COMMENT graceful shutdown
TODO commented out because, sometimes I accidentally shutdown emacs.
Eg: when an emacs - in - emacs  is launched by mail_compose. If I close that child emacs, laptop shuts down.

https://emacs.stackexchange.com/questions/29919/shutting-down-computer-from-emacs-killing-gracefully-emacs-itself

This should shutdown only on tty0 which runs the GUI. So that, I can still C-x C-c to close emacs without laptop shutdown on other ttys.
#+begin_src emacs-lisp :tangle window_manager.el
(add-hook 'kill-emacs-hook
          #'(lambda () (if (display-graphic-p)
                      (shell-command "sleep 5 && shutdown now")))
          t)
#+end_src

Instead try to see if you can optionally bind this to C-u C-x C-c

** exwm external monitor
*** COMMENT enable one VGA external monitor
#+begin_src emacs-lisp :tangle window_manager.el
(require 'exwm-randr)
(setq exwm-randr-workspace-output-plist
      '(0 "LVDS1" 1 "VGA1"))
(setq exwm-randr-workspace-monitor-plist '(0 "LVDS1" 1 "VGA1"))

(add-hook 'exwm-randr-screen-change-hook
          (lambda ()
            ;;(start-process-shell-command "xrandr" nil "xrandr --output LVDS1 --output VGA1 --auto")
            ;;(start-process-shell-command "xrandr_script" nil "bash /home/anoop/scripts/bidare_external_monitor_to_right_2023.sh")
            (start-process-shell-command "xrandr_script" nil "bash /home/anoop/scripts/bidare_external_monitor_to_right_2024.sh")))

(exwm-randr-mode +1)
#+end_src
*** COMMENT enable one DP external monitor
#+begin_src emacs-lisp :tangle window_manager.el
(require 'exwm-randr)
;;(setq exwm-randr-workspace-output-plist '(0 "LVDS1" 1 "DP1"))
(setq exwm-randr-workspace-monitor-plist '(0 "LVDS1" 1 "DP1"))

(add-hook 'exwm-randr-screen-change-hook
          (lambda ()
            ;;(start-process-shell-command "xrandr" nil "xrandr --output LVDS1 --output VGA1 --auto")
            ;;(start-process-shell-command "xrandr_script" nil "bash /home/anoop/scripts/bidare_external_monitor_to_right_2023.sh")
            ;;(start-process-shell-command "xrandr_script" nil "bash /home/anoop/scripts/bidare_external_monitor_to_right_2024.sh")
            (message "dummy placeholder")
            ))

(exwm-randr-mode +1)
#+end_src

*** COMMENT disable external monitor
#+begin_src emacs-lisp :tangle window_manager.el
(require 'exwm-randr)
(setq exwm-randr-workspace-output-plist
      '(0 "LVDS1"))

;;(add-hook 'exwm-randr-screen-change-hook
;;          (lambda ()
;;            (start-process-shell-command "xrandr_script" nil "bash /home/anoop/scripts/bidare_disable_external_monitor_2023.sh")))

(global-set-key (kbd "M-o") 'other-window)
(global-set-key (kbd "C-x o") 'other-window)
#+end_src
*** TODO COMMENT Control external monitor brightness using shell script
[[file:~/Dropbox/job.org::*Set brightness of external monitor][Set brightness of external monitor]]
https://aur.archlinux.org/packages/gddccontrol
*** COMMENT Move buffer to other monitor
^disabled because, I dont like the current implementation.
Also, I dont know how to bind a key in all buffers except exwm-mode buffers

By default, in exwm-mode buffers, =C-c RET= works. But, it has a bug in numbering of my external monitors:-
#+begin_quote https://www.gnu.org/software/emacs/manual/html_node/elisp/Cyclic-Window-Ordering.html
If more than one frame is considered, the cyclic ordering is obtained by appending the orderings for those frames, in the same order as the list of all live frames
#+end_quote

Let me extend this feature to all buffers, ie, even /non exwm-mode/ buffers
#+begin_src emacs-lisp :tangle window_manager.el
(global-set-key (kbd "C-c <return>") 'exwm-workspace-move)
(bind-keys :map exwm-mode-map
           ("C-c <return>" . exwm-workspace-move-window)
           ("C-c RET" . exwm-workspace-move-window))
#+end_src
*** Set the number of workspaces
The default is 1.
#+begin_src emacs-lisp :noweb-ref "imac only"
(setq exwm-workspace-number 3)
#+end_src

*** Enable iMac and two Displayport monitors
Builtin display is called eDP
The vertical monitor is called DisplayPort-2 and the rightmost horizontal monitor is called DisplayPort-1

#+begin_src emacs-lisp :noweb-ref "imac only"
(require 'exwm-randr)
;;(setq exwm-randr-workspace-output-plist '(0 "LVDS1" 1 "VGA1"))
;;(setq exwm-randr-workspace-monitor-plist '(0 "eDP" 1 "DisplayPort-1" 2 "DisplayPort-2"))
(setq exwm-randr-workspace-monitor-plist '(0 "eDP" 1 "DisplayPort-2" 2 "DisplayPort-1"))

(add-hook 'exwm-randr-screen-change-hook
          (lambda ()
            (start-process-shell-command "xrandr_script0" nil "bash /home/anup/scripts/anoop-imac-landscape-potrait-landscape.sh")))

(exwm-randr-mode +1)
#+end_src
**** Map workspace numbers to monitors
There is a bug in workspace numbering, just editing plist to
~(setq exwm-randr-workspace-monitor-plist '(0 "eDP" 1 "DisplayPort-2" 2 "DisplayPort-1"))~
does fix it. But, at the cost of [[*Move buffer to other monitor][messing up]] the ordering of emacs frames, which results in messing up the ordering of =M-o=.
Someday, Below may be able to fix it:-
#+begin_quote https://old.reddit.com/r/emacs/comments/cyuqbp/exwm_multimonitor_setup/#:~:text=rebuild%20exwm-randr-workspace-output-plist%20so%20they're%20numbered%20bottom-%3Etop%2C%20left-%3Eright.
rebuild exwm-randr-workspace-output-plist so they're numbered bottom->top, left->right.
#+end_quote
***** COMMENT lazy attempt at above, by copying reddit solution
This [[https://old.reddit.com/r/emacs/comments/cyuqbp/exwm_multimonitor_setup/][reddittor]] has code that uses =$ xrandr= output in elisp to  assign monitor names etc.
His code needs massaging to make it work. But the helper function ~my/exwm-screen-change~ works.
I need to change the old name ~exwm-randr-workspace-output-plist~ to new name ~exwm-randr-workspace-monitor-plist~

BTW, manually hardcoding the ordering did not work.

***** clever approach to fix above problem, ~anup/other-window~
Let the ordering of emacs frames remain fucked up. Handle that mess by redefining ~other-window~ itself.

#+begin_src emacs-lisp
(defun anup/other-window ()
  (interactive)
  (other-window 2 t))
#+end_src
^But, above hardcoded =2= doesnt work only when exactly =3= windows are open. Lets generalise it.
Above works fine if only two monitors are active. (?Because frame ordering doesnt matter then)

#+begin_src emacs-lisp
(defun anup/other-window ()
  (interactive)
  (let ((N (count-windows nil t)))
    (other-window (- N 1) t)))
#+end_src
^Above breaks whenever there are multiple windows in any frame.
ie The ordering of windows is reversed during M-o cycling. If there are 4 windows open on a frame, the bottom rightmost window is entered first. Whereas, I want it to pick the top leftmost window first.
ie Above solution fixes the ordering of frames, while accidentally reversing the ordering of windows within a particular frame.
---------------------------------------------------------------------------------------------------
The correct algorithm is:-
1. If there is a single window on this frame, then /skip/ is equal to the number of windows on the hardware-monitor to the left of current hardware-monitor.
2. If there are multiple windows on this frame, and this /isnt the last window on the current frame/, then /skip/ is equal to 0.
3. If there are multiple windows on this frame, and this /is the last window on the current frame/, then /skip/ is the same as in =step 1.=
[[xournalpp:other window bugfix.xopp]]

The pseudo code for the above algorithm, the ~cond~ returns the /skip/
#+begin_src emacs-lisp :noweb-ref "Skip these many windows"
(cond (<<There is a single window on this frame?>> <<Number of windows in the frame to the left of the current frame>>)
      ((and <<There are multiple windows on this frame?>>
            <<This isnt the last window on this frame?>>) 0)
      ((and <<There are multiple windows on this frame?>>
            <<This is the last window on this frame?>>) <<Number of windows in the frame to the left of the current frame>>))
#+end_src


For above algorithm, I also need a way to count the number of windows on each frame. ~window-list~ will do it.
(If some window has ~no-other-window~ parameter set, then dont count it.)
#+begin_src emacs-lisp :noweb-ref "There is a single window on this frame?"
(= (length (cl-remove-if 'window-no-other-p (window-list (selected-frame)))) 1)
#+end_src
#+begin_src emacs-lisp :noweb-ref "There are multiple windows on this frame?"
(> (length (cl-remove-if 'window-no-other-p (window-list (selected-frame)))) 1)
#+end_src

I need a way to find out whether the current window is the last window on the current frame.
~window-list~ has no gurantees on the ordering of its ret. ~winner-sorted-window-list~ does gurantee a top to bottom, left to right ordering. This same ordering is respected by the builtin ~other-window~.
#+begin_src emacs-lisp :noweb-ref "This is the last window on this frame?"
(eq (selected-window) (-last-item (winner-sorted-window-list)))
#+end_src
#+begin_src emacs-lisp :noweb-ref "This isnt the last window on this frame?"
(not <<This is the last window on this frame?>>)
#+end_src

winner-mode is a builtin. But it needs to be loaded so ~winner-sorted-window-list~ is not undefined.
#+begin_src emacs-lisp :noweb-ref "Ensure winner dependency is loaded"
(use-package winner
  :ensure nil ;;builtin
  )
#+end_src

---------------------------------------------------------------------------------------------------
My algorithm needs a way to refer to the frame to the left of the current frame.
To implement this, I think it is helpful to have names to the three frames. ie Find a way to add string labels to my three frames.
Hence, stopped work on this till I figure out how to add labels to frames.
Although I dont have labels for frames, I do have them for workspaces.
Every frame contains one workspace.
Therefore, workspace +names+ numbers can be used to indirectly refer to frames.
ie, my algorithm just needs a way to refer to the workspace to the left of the current one:-
#+begin_src emacs-lisp :noweb-ref "Workspace number for the workspace to the left of the current workspace"
(% (+ exwm-workspace-current-index 2) 3)
#+end_src

The value of ~exwm-workspace-current-index~ is ~0, 1, 2~ respectively for iMac, Vertical Monitor, Horizontal Monitor.
Above index can also be used to retrive the corresponding frame by utilizing the badly named ~exwm-workspace--workspace-from-frame-or-index~
#+begin_src emacs-lisp :noweb-ref "Get the frame to the left of current frame"
(exwm-workspace--workspace-from-frame-or-index <<Workspace number for the workspace to the left of the current workspace>>)
#+end_src

#+begin_src emacs-lisp :noweb-ref "Number of windows in the frame to the left of the current frame"
(length (cl-remove-if 'window-no-other-p (window-list <<Get the frame to the left of current frame>>)))
#+end_src
If some window has ~no-other-window~ parameter set, then dont count it.

Now, we have all the code needed to calculate the /skip/
We can use it to define our other-window
#+begin_src emacs-lisp :tangle window_manager.el
<<Ensure winner dependency is loaded>>
(defun anup/other-window ()
  (interactive)
  (other-window (+ 1 <<Skip these many windows>>) 'visible))
#+end_src
^The ~+ 1~ is needed to skip the current window. This is a bit odd, but it makes sense because ~other-window~ carries the burden of supporting negative arguments as well.
We bind above to =M-o= elsewhere.

****** COMMENT other ideas
TODO This doesnt handle occassional single monitor setup.

TODO explore an alternative solution. Currently the rightmost monitor is given numbering 1, middle one 2, and builtin one 3.
#+begin_quote as evident by the output of (frame-list)
(#<frame an example0 buffer on the rightmost monitor 0x5be14faa7410> #<frame an example0 buffer on vertical monitor 0x5be15139b9d0> #<frame an example0 buffer on builtin monitor 0x5be14cf5c878>)
#+end_quote
Will a delayed attachment of external monitors force the builtin monitor be given number 1?
**** The icons on the inbuilt monitor are too small
Is it even fixable?

#+begin_quote https://github.com/johanwiden/exwm-setup#:~:text=EXWM%20has%20only,vertical%20and%20horizontal).
EXWM has only one X11 display, to which all monitors are attached as X11 screens (what xrandr calls output), so you can freely move the mouse between monitors. For more on using several monitors with X11, and terminology for this, see Multihead.

A downside with using just one X11 display, is that X11 will use the same virtual resolution (Dots Per Inch, DPI) on all screens. The xrandr option dpi is per display, not per screen. If you have a high resolution monitor and a low resolution monitor in your setup, and you want to use them together, you will probably have to make some ugly compromise.

I have a HiDPI laptop, that can have up to 246 physical DPI, and an external monitor with up to 106 physical DPI. My compromise is that I configure the laptop display to use a resolution (number of horizontal and vertical pixels ), that is much lower than what the monitor supports. This results in text being about the same size on both monitors, but also somewhat unsightly black borders at the left and right side of the laptop monitor (the screen and the monitor have different proportions between vertical and horizontal).
#+end_quote

[[https://github.com/ch11ng/exwm/issues/64][Try setting Xft.dpi]] But how to set it for only one monitor?

***** COMMENT try 1 - failed
#+begin_src emacs-lisp
(set-face-attribute 'mode-line nil :family "Iosevka Slab" :height 250)
(set-frame-font "Iosevka Slab 25" nil nil)

;;default wasy ((width . 80) (height . 2))
;;tried, but didnt have any visible effect:-
;;(setq minibuffer-frame-alist '((width . 80) (height . 4)))

;;below only increases the size of 'M-x' in the minibuffer, without increasing the size of the command
;;(set-face-attribute 'minibuffer-prompt nil :family "Iosevka Slab" :height 300)
#+end_src

Lets set the frame fonts a bit bigger on iMac screen.
Lets ensure that we have iMac's builtin screen active. We are doing  this because ~set-frame-font~ implicitly affects just the current frame when run with a single argument.

You can use the select-frame-set-input-focus function programmatically to select a specific frame based on its number:
The way our frame-list is ordered, iMac's inbuilt screen is the last entry, at index 2.
#+begin_src emacs-lisp
(select-frame-set-input-focus (nth 2 (frame-list)))
(set-face-attribute 'mode-line nil :family "Iosevka Slab" :height 250)
(set-frame-font "Iosevka Slab 25") ;;implicit assumption, this line runs when the active frame, is the one on builtin imac screen
#+end_src

Above should happen only on my iMac.
#+begin_src emacs-lisp
(if (equal system-name "imac0")
    ;;call all the above commands inside a progn here
    )
#+end_src

If I could name each of my frames, using ~set-frame-name~, this code would simplify a lot.

***** CANCELLED COMMENT Programmatically store the frame reference
For some reason, below always prints ~nil~. Hence, went with above approach.
#+begin_src emacs-lisp
(let (imac-builtin-hardwaremonitors-frame-name (selected-frame))
  (princ imac-builtin-hardwaremonitors-frame-name))
#+end_src
***** COMMENT try2 - works, but tedious
Just go to a scratch buffer on the iMac screen, and =C-x C-e= on below:-
#+begin_src emacs-lisp
(set-face-attribute 'mode-line nil :family "Iosevka Slab" :height 250)
(set-frame-font "Iosevka Slab 25" nil nil)
#+end_src
***** DONE Increase font size on iMac frame, and modeline font size, after exwm has just finished starting.
It is appropriate to run this code after EXWM starts up.
+?Below noweb-ref "On emacs startup" runs after EXWM starts up.+
#+begin_src emacs-lisp :noweb-ref "imac only"
(add-hook 'exwm-init-hook (lambda ()
                            ;;select frame on iMac
                            (select-frame-set-input-focus (nth 2 (frame-list)))
                            ;;wait for previous step to complete and then run the below code
                            (run-with-timer 1
                                            nil
                                            (lambda () (progn (set-face-attribute 'mode-line (selected-frame) :family "Iosevka Slab" :height 250)
                                                         (set-frame-font "Iosevka Slab 25" nil nil)
                                                         <<Set imac screen cursor color hacky>>)))))
#+end_src

*** COMMENT turn working.sh into elisp
Someday, add hotplugging support
#+begin_src emacs-lisp :tangle window_manager.el
(defun anup/triple-monitor ()
  (start-process-shell-command "xrandr_script0" nil "bash /home/anup/scripts/anoop-imac-landscape-potrait-landscape.sh"))

(add-hook 'exwm-randr-screen-change-hook 'anup/triple-monitor)
(exwm-randr-mode +1)
#+end_src
** Fix helm bug of C-x C-b not listing X-buffers from other frames
X-windows from other frames start with a space

So, I removed the regexp that treated buffers starting with a space as boring
ie removed the regexp "\\` "

But, I will still treat buffers with names starting with space followed by a =*= as boring
These can be matched by the regexp "\\` \\*"
#+begin_src emacs-lisp :tangle window_manager.el
(setq helm-boring-buffer-regexp-list
      '(;;"\\` "
	"\\` \\*"
	"\\`\\*helm" "\\`\\*Echo Area" "\\`\\*Minibuf"))
#+end_src

A similar change is needed for ivy and counsel (counsel internally calls out to ivy).
#+begin_src emacs-lisp :tangle window_manager.el
(setq ivy-ignore-buffers '(;;"\\` "
                           "\\`\\*tramp/"))
#+end_src
But, still unable to list other frame exwm buffers using ~counsel-switch-buffer~ and ~ivy-switch-buffer~
This bug was fixed in [[*fix for: counsel buffer switcher - does not show exwm buffers in other frames][fix for: counsel buffer switcher - does not show exwm buffers in other frames]]

** Hide some more boring buffers
#+begin_src emacs-lisp :tangle window_manager.el
(setq helm-boring-buffer-regexp-list (cons "*quelpa-build-checkout*" helm-boring-buffer-regexp-list))
(setq helm-boring-buffer-regexp-list (cons "tq-temp-epdfinfo" helm-boring-buffer-regexp-list))
(setq helm-boring-buffer-regexp-list (cons "*pdf-scroll-log*" helm-boring-buffer-regexp-list))
#+end_src

All buffers starting with the string ~magit-process:~
#+begin_src emacs-lisp :tangle window_manager.el
(setq helm-boring-buffer-regexp-list (cons "\\magit-process:" helm-boring-buffer-regexp-list))
#+end_src

My vuiet configuration creates some mpv windows that are of no interest to me
#+begin_src emacs-lisp :tangle window_manager.el
;;(setq helm-boring-buffer-regexp-list (cons "\\No file - mpv -- mpv" helm-boring-buffer-regexp-list))
(setq helm-boring-buffer-regexp-list (cons "\\tq-temp" helm-boring-buffer-regexp-list))
#+end_src

some more
#+begin_src emacs-lisp :tangle window_manager.el
(setq helm-boring-buffer-regexp-list (cons "*straight-process*" helm-boring-buffer-regexp-list))
(setq helm-boring-buffer-regexp-list (cons "*Compile-Log*" helm-boring-buffer-regexp-list))
(setq helm-boring-buffer-regexp-list (cons "*Async-native-compile-log*" helm-boring-buffer-regexp-list))
(setq helm-boring-buffer-regexp-list (cons "*XELB-DEBUG*" helm-boring-buffer-regexp-list))
#+end_src

** CANCELLED C-x b filtering update
^applicable only to helm, which I have abandoned.

C-x b filtering should also match the rightmost column
ie,
If I type ~dired~, it should filter the buffer list to only those which have
either dired in their buffer names or have dired in the rightmost column

Also,
C-x b "goo..." should preserve the order among recent google chrome buffers

** DONE Leechblock for exwm C-c p
See if you can hide google-chrome-stable from the C-c p launch list,
kinda like leechblock for desktop

** DONE When hdmi or vga cable is disconnected, automatically move exwm windows from the switched off monitor back to laptop screen
+Currently, an annoying problem is that some chrome windows remain running on the turned off monitor+
This automatically happens. Because, exwm sends frames from turned off monitors to the present active monitor.
** TODO COMMENT Send a reload event to your Rails app
source: https://github.com/ch11ng/exwm/wiki/Cookbook#programmatically-sending-keys-to-x-applications
You can use xdotool to do so. Install it =pacman -S xdotool=
It needs an X window ID to be able to send to an application that's not currently focused, so we need to provide that.
#+begin_src emacs-lisp :tangle window_manager.el
(defun my/page-reload ()
  "Send a reload event to my Rails app."
  (interactive)
  (let ((key "F5")
        (window-id (with-current-buffer
                       ;;you can find out argument for get-buffer function using M-; (buffer-name)
                       (get-buffer "- http://127.0.0.1:3000/ - Google Chrome -- Google-chrome")
                     (exwm--buffer->id (current-buffer)))))
    (shell-command-to-string
     (format "xdotool key --window %s %s" window-id key))))
#+end_src

** shutdown, reboot, suspend computer
#+begin_src emacs-lisp :tangle window_manager.el
(defun shutdown-computer ()
  "Shut down the computer."
  (interactive)
  (let ((shut-down (lambda ()
                     (shell-command "systemctl poweroff"))))
    (add-hook 'kill-emacs-hook shut-down)
    (save-buffers-kill-emacs)
    (remove-hook 'kill-emacs-hook shut-down)))

(defun reboot-computer ()
  "Reboot the computer."
  (interactive)
  (let ((reboot (lambda ()
                  (shell-command "reboot"))))
    (add-hook 'kill-emacs-hook reboot)
    (save-buffers-kill-emacs)
    (remove-hook 'kill-emacs-hook reboot)))
(defalias 'restart-computer 'reboot-computer)

(defun suspend-computer ()
  "Put computer to sleep"
  (interactive)
  ;;(start-process "suspend" nil "systemctl" "suspend" "-i")
  ;;(shell-command "systemctl suspend")
  ;;Does using sudo to sleep help fix bugs?
  (shell-command "echo jjf | systemctl suspend &"))

(defalias 'sleep-computer 'suspend-computer)

(defun kill-startx ()
  "Kill 9 the X server"
  (interactive)
  (shell-command "kill -9 $(pgrep Xorg)")
  ;;(start-process "killstartx" nil "kill" "-9" "$(pgrep startx)")
  )
#+end_src
** Emacs key bindings in X windows

This is super nice, because I love these key bindings and they are just
intuitive to me, and now they can carry over safely to other programs.

*** set some simulation keys
#+begin_src emacs-lisp :noweb-ref "Add to exwm-input-simulation-keys"
;;unable to bind '<' or '>' in exwm due to a known exwm issue
;;(,(kbd "M-<") . home) 
;;(,(kbd "M->") . end)
;;([?\M-<] . [C-home])
;;([?\M->] . [C-end])

;; Go to begin and end of window
([?\C-a] . [home])
([?\C-e] . [end])

([?\C-b] . [left])
([?\C-f] . [right])
([?\C-p] . [up])
([?\C-n] . [down])

;;Navigate by paragraphs
([?\M-b] . [C-left])
([?\M-f] . [C-right])
([?\M-n] . [C-down])
([?\M-p] . [C-up])

;; disabled because I prefer caret-mode for selecting text in qutebrowser
;;however someday, this might become useful if I start using some X window program other than qutebrowser extensively
;; Selecting via navigation
;; (,(kbd "C-S-b") . [S-left])
;; (,(kbd "C-S-f") . [S-right])
;; (,(kbd "C-S-n") . [S-down])
;; (,(kbd "C-S-p") . [S-up])

;;how the fuck does below not conflict with keybindings defined in config.py for qutebrowser?
;;DOUBT:-
;;does keybinding pass through EXWM to qutebrowser or
;;does it pass directly to qutebrowser
;;does it differ from line-mode to char-mode of EXWM
;; Copy/Paste
([?\C-w] . [?\C-x])
([?\M-w] . [?\C-c])
([?\C-y] . [?\C-v])

;;disbled because I have bound this instead in qutebrowser's config.py
;;however someday, this might become useful if I start using some X window program other than qutebrowser extensively
;;Search
;;([?\C-s] . [?\C-f])

;;undo
([?\C-\/] . [?\C-z])

;; Other
([?\C-d] . [delete])
([?\M-d] . [C-delete])
([?\C-k] . [S-end delete])

;;disbled because I have bound this instead in qutebrowser's config.py
;;([?\C-g] . [escape])

#+end_src
*An extra newline is required to ensure that when above block gets tangled, the last line doesnt comment out the brackets in the parent*.
ie if there is no newline, after tangling, above becomes
~;;([?\C-g] . [escape])))~ and hence accidentally comments out the two closing braces.
This is a limitation of my current literate programming setup. The child blocks cannot have commented out lines as their last lines.

If I universally *always* use comment a sexp syntax, then I dont have to worry about above problem.
Hence, move to sexp based commenting syntax. Unfortunately elisp doesnt have a syntax for it. But, Clojure does have it.

*** =C-s=
Key sequences cannot be defined in =exwm-input-simulation-keys=
This is a known exwm weakness. However, there is a nice trick to circumvent this deficiency.

We define and call elisp functions in order to provide the desired behavior.  The
functions that follow ensure that keys I use in Emacs behave similarly in X
windows as they do in Emacs itself.

Firstly, lets define all these functions.

The first is for saving.  Since Emacs uses =C-x C-s= to save, a function has
to be written to simulate that by pressing =C-q= then =C-s=, to send =C-s=
verbatim to the X window.

#+begin_src emacs-lisp :tangle window_manager.el
(defun farl-exwm/C-s ()
  "Pass C-s to the EXWM window."
  (interactive)
  (execute-kbd-macro (kbd "C-q C-s")))
#+end_src

*** =C-k=

# The next function is one meant to create a link in Telegram and do a number
# of other things in other programs.  It is placed on the same key sequence
# that Org-mode uses to place links: =C-c C-l=.
^I have no clue what the fuck that means 🤔

#+begin_src emacs-lisp :tangle window_manager.el
(defun farl-exwm/C-k ()
  "Pass C-k to the EXWM window."
  (interactive)
  (execute-kbd-macro (kbd "C-q C-k")))
#+end_src

*** Select All

This function is meant to push =C-a=, which selects all text.  It is bound to
=C-x h= since that's the equivalent key in Emacs.

#+begin_src emacs-lisp :tangle window_manager.el
(defun farl-exwm/C-a ()
  "Helper to select all text when in EXWM buffers."
  (interactive)
  (execute-kbd-macro (kbd "C-S-<f3>")))
#+end_src

Note: =C-S-<f3>= is set inside the qutebrowser config.py file.

*** =C-o=

I want this to open a newline at end of current line.
This function is meant to mimic the behavior =C-o= has in a standard Emacs
buffer.  It should push what follows onto a new line while staying on the
current line.

#+begin_src emacs-lisp :tangle window_manager.el
(defun farl-exwm/C-o ()
  "Pass the equivalent of C-o to the EXWM window."
  (interactive)
  (execute-kbd-macro (kbd "<S-return> C-b")))
#+end_src

*** M-< and M->
This keybinding is currently useful only in qutebrowser.
In [[file:~/Dropbox/job.org::*scroll to top/bottom][qutebrowser's configuration]], I have bound <F6> and <F7> to scroll to beginning & end of buffer respectively

ie,
User presses =M-<=   --->      EXWM translates it to =<Control + Shift + F1>=   -->    Qutebrowser scrolls to top

#+begin_src emacs-lisp :tangle window_manager.el
(defun anup/M-< ()
  "Move to end of qutebrowser window"
  (interactive)
  (execute-kbd-macro (kbd "C-S-<f1>")))
(defun anup/M-> ()
  "Move to beginning of qutebrowser window"
  (interactive)
  (execute-kbd-macro (kbd "C-S-<f2>")))
#+end_src

*** Binds
Secondly, lets bind these above defined functions

These functions are bound to keys in =exwm-mode-map=.

#+begin_src emacs-lisp :noweb-ref "Bindings inside exwm-mode-map"
("C-c C-l" . farl-exwm/C-k)
("C-x C-s" . farl-exwm/C-s)
("C-x h" . farl-exwm/C-a)
("C-o" . farl-exwm/C-o)
("M-<" . anup/M-<)
("M->" . anup/M->)
#+end_src

** On Emacs+EXWM Startup
*** intro   
This is everything that should be started or run when EXWM starts.

#+begin_src emacs-lisp :noweb yes :noweb-ref "Exwm init"
  (defun farl-exwm/on-startup ()
    "Start EXWM and related processes."
    <<On emacs startup>>)
#+end_src
^This function is run during =after-init-hook=.

#+begin_src emacs-lisp :noweb-ref "exwm/hook"
(after-init . farl-exwm/on-startup)
#+end_src
*** XDG compliance and WM settings
I have stolen this from someone's config

I have to set a few environment variables for the sake of compliance with
various specifications, most notably the XDG Base Directory Specification.
Also in this block I set an environment variable signaling to Java
applications that the window manager is not a reparenting window manager.

#+begin_src emacs-lisp :noweb-ref "On emacs startup"
(setenv "XDG_CURRENT_DESKTOP" "emacs")
;;(setenv "GTK2_RC_FILES" (expand-file-name "~/.config/gtk-2.0/gtkrc"))
(setenv "QT_QPA_PLATFORMTHEME" "gtk2")
(setenv "_JAVA_AWT_WM_NONREPARENTING" "1")
#+end_src

*** Disable screen blanking
This is kinda like /caffeine/ binary for Mac.

I don't need my laptop's screen shutting off just because I'm sitting and
watching a video with the laptop idle too long.
#+begin_src emacs-lisp :noweb-ref "On emacs startup"
(start-process "Disable Blanking" nil "xset" "s" "off" "-dpms")
#+end_src
*** COMMENT Notifications
Someday maybe, set this up

There is currently still no Emacs based notifications manager that I can
personally get behind, and I by no means have enough Emacs Lisp know-how to
properly write such a package.  Because of this, I'm stuck using ~dunst~.

#+begin_src emacs-lisp :noweb-ref "On emacs startup"
(start-process "Notifications" nil "dunst")
#+end_src
*** COMMENT Start the compositor
Someday maybe, set this up

I don't need it, but having basic compositing is very nice.

#+begin_src emacs-lisp :noweb-ref "On emacs startup"
(start-process "Compositor" nil "xcompmgr")
#+end_src

*** COMMENT Move some crap from .xinitrc to here
Such as starting /unclutter/ binary to hide the cursor after 3 second idling, emods2.sh etc.
*** Set keyboard repeat delay and repeat rate
The maximum repeat rate permitted is 255/second
Wait for 200ms before starting repeat. Once started, repeat at a rate of 60/second.
#+begin_src emacs-lisp :noweb-ref "On emacs startup"
(start-process "Set keyboard repeat rate" nil "xset" "r" "rate" "200" "60")
#+end_src
*** Hide the mouse pointer
hide mouse cursor when cursor movement is idle for sometime
I think this also hides the cursor while typing
#+begin_src emacs-lisp :noweb-ref "On emacs startup"
(set-process-query-on-exit-flag
 (start-process "Hide mouse pointer" nil "unclutter")
 nil)
#+end_src
*** Set fallback cursor
Requires ~pacman -S xsetroot~

Some X windows will have weird cursors if this isn't done.

#+begin_src emacs-lisp :noweb-ref "On emacs startup"
(start-process "Fallback Cursor" nil "xsetroot" "-cursor_name" "left_ptr")
#+end_src

*** COMMENT Setup mouse for left handed usage
This is no longer needed as I have started using a left handed hardware mouse from Perixx. The left handedness is builtin into that hardware.
#+begin_src emacs-lisp :noweb-ref "On emacs startup"
(shell-command "xmodmap -e 'pointer = 3 2 1 4 5'")
#+end_src
*** TODO Start polkit manager
Move this from xinitrc to here
*** TODO COMMENT Keyboard configuration

    # This block sets the keyboard layout to US and give Caps Lock the
    # functionality of Control.  I was hesitant to do this at first, but it's
    # significantly more comfortable.  I almost never used caps lock as it is,
    # given my keyboards have no indicator for it on my laptops, but this gives me
    # a much easier way to do commands without shifting my hand too far.  Ideally,
    # however, I configure my keyboards so that this setting is nothing more than
    # an afterthought.

    #+begin_src emacs-lisp  :noweb-ref "On emacs startup"
    (start-process "Keyboard Layout" nil "setxkbmap" ;
                   "us" "-option" "ctrl:nocaps")
    #+end_src

    Insert contents from =~/scripts/emods2.sh= and delete above codeblock's contents

*** TODO COMMENT Disable the trackpad

Insert contents from =~/scripts/toggle-trackpad.sh= and delete below codeblock's contents.
Make this sectio laptop only.

    #+begin_src emacs-lisp  :noweb-ref "On emacs startup"
      (start-process "Trackpad Setup" nil "xinput"
                     "disable" (shell-command-to-string
                                (concat "xinput | grep Synap | head -n 1 | "
                                        "sed -r 's/.*id=([0-9]+).*/\\1/' | "
                                        "tr '\n' ' ' | sed 's/ //'")))
    #+end_src


** On logout
When exiting emacs, these are things I want done.

#+begin_src emacs-lisp :noweb yes :noweb-ref "Exwm init"
(defun farl-exwm/on-logout ()
  "Run this when logging out as part of `kill-emacs-hook'."
  <<On closing emacs>>)
#+end_src

This is hooked into when Emacs is killed.
#+begin_src emacs-lisp :noweb-ref "exwm/hook"
(kill-emacs . farl-exwm/on-logout)
#+end_src

*** Black out the root window
This requires ~yay -S hsetroot~

This way, it looks good when exiting Emacs.
But disabled it because it making emacs not close properly on =C-x C-c= due to some bug.
#+begin_src emacs-lisp :noweb-ref "On closing emacs"
;;(start-process "Root window" nil "hsetroot" "-solid" "'#000000'")
#+end_src

*** Quit Qutebrowser
By default, qutebrowser restores previous session if it ever crashes.
Qutebrowser considers that it has crashed whenever EXWM sends it a kill command through C-q in helm-buffers.

I want to disable this kind of crash handling by qutebrowser altogether
I found that it saves its current session in a file on disk.
Deleting this file will ensure that Qutebrowser never has access to what all tabs were open in the previous session.

Let me try removing that session file everytime emacs closes.
#+begin_src emacs-lisp :noweb-ref "On closing emacs"
(start-process "Erase Qutebrowser session on emacs close" nil "rm" "/home/anup/.local/share/qutebrowser/sessions/_autosave.yml")
#+end_src
^Using =~/.local/...= instead of =/home/anup/...= isnt supported.

** Single monitor setup
#+begin_src emacs-lisp :tangle window_manager.el
(defun single-monitor-setup ()
  "Only the iMac0 screen is active. All external monitors are off."
  (interactive)
  (global-set-key (kbd "M-o") 'other-window)
  (global-set-key (kbd "C-x o") 'other-window)
  ;; Since on iMac internal screen is active, let me adjust the font size too
  ;; The default was (:background "black" :foreground "gray60" :inverse-video nil :box (:line-width 1 :color "#1A2F54"))
  ;;(set-face-attribute 'mode-line nil :family "Iosevka Slab" :height 250)

  ;;(set-frame-font "Iosevka Slab 25" nil nil)

  ;;default wasy ((width . 80) (height . 2))
  ;;tried, but didnt have any visible effect:-
  ;;(setq minibuffer-frame-alist '((width . 80) (height . 4)))

  ;;(set-face-attribute 'minibuffer-prompt nil :family "Iosevka Slab" :height 250)
  )

(defun multi-monitor-setup ()
  "Setup keybindings for one iMac0 screen and two external monitors."
  (interactive)
  <<Bind anup/other-window>>)
#+end_src

TODO Add =arandr= toggle to above

Dual monitor setup
#+begin_src emacs-lisp :tangle window_manager.el
(defun dual-monitor-setup ()
  "Setup keybindings for one iMac0 screen and one external monitor."
  (interactive)
  (bind-keys :map global-map
           ("M-o" . (lambda ()
                      (interactive)
                      (other-window 1 t)))
           ("C-x o" . (lambda ()
                        (interactive)
                        (other-window 1 t)))))
#+end_src

** TODO Make =M-g <some char>=, =C-c <bla>= work in exwm buffers
^below tricks didnt work

I may have to tell exwm that =M-g= is a prefix key using :noweb-ref "Exwm config"
This is done by adding to the list ~exwm-input-prefix-keys~. An emacs restart is required for the new modified list to be respected.
#+begin_src emacs-lisp
(push ?\M-g exwm-input-prefix-keys)
#+end_src
~push~ mutates a list inplace.

Do the same with the =C-c= prefix in :noweb-ref "Exwm config"
#+begin_src emacs-lisp
;;Note that below is a bad idea if I ever want to bind C-c M-w inside my qutebrowser config.py
(push ?\C-c exwm-input-prefix-keys)
#+end_src

^Above doesnt work because:-
#+begin_quote Above probably failed because:-
Notes:
Setting the value directly (rather than customizing it) after EXWM
  finishes initialization has no effect.
#+end_quote

Let me hence use ~:custom~
#+begin_src emacs-lisp
(exwm-input-prefix-keys (push ?\M-g exwm-input-prefix-keys))
(exwm-input-prefix-keys (push ?\C-c exwm-input-prefix-keys))
#+end_src
^This fails because ~exwm-input-prefix-keys~ isnt defined when ~:custom~ is run

Hence, try setting them in ~:init~
There is no need to ~setq~ because ~push~ desctructively mutates in place.
#+begin_src emacs-lisp :noweb-ref "Exwm init"
(push ?\M-g exwm-input-prefix-keys)
(push ?\C-c exwm-input-prefix-keys)
#+end_src

** =M-x exwm-randr-refresh2=
Lets say, I had turned off the external monitors during bootup. After bootup, if I turn on those monitors, they start showing the same frame as the one on builtin iMac monitor. To refresh the monitor layout, I need to call ~exwm-randr-refresh~.

The default ~exwm-randr-refresh~ doesnt work with my triple monitor setup, for some unknown reason. However, I observed that after calling that builtin, if I open =arandr=, then, the triple monitors do refresh their layouts. (BTW, instead of arandr, opening any X-window app will work too. Eg: =gnome-calendar=)

Hence, let me define my own randr refresh command, that makes use of above trick
#+begin_src emacs-lisp :tangle window_manager.el
(defun exwm-randr-refresh2 ()
  "randr refresh that works with anups triple monitor setup"
  (interactive)
  (exwm-randr-refresh)
  (message "Opening arandr, this forces exwm to refresh its layout")
  (call-process-shell-command "arandr &" nil 0)
  ;;for good measure, call the builtin once again:
  (exwm-randr-refresh)
  ;;wait for 3 seconds, and then close the gnome-calendar:
  (run-with-timer 2
                  nil
                  'anoop/kill-this-buffer))
#+end_src

** Prevent Dropbox app from creating dialogs
I wish I could prevent just Dropbox from creating dialog frames. Unfortunately, I only know how to prevent all X applications from creating dialog boxes.
This achieves my goal. But it is known to break Gimp etc
#+begin_src emacs-lisp :noweb-ref "Exwm config"
(setq exwm-manage-force-tiling t)
#+end_src
